include "std"
include "compiler/class/Op"
include "compiler/class/Token"
include "compiler/class/TypeNode"

// Create Array of integer types
// TODO: Enable creating constant arrays
// Params None
// Return
//    INTEGER_TYPES: Array
function INTEGER_TYPES -> ptr :
  5 Array.init
  take array in
  TokenType.ANY   ptr array Array.append
  TokenType.BOOL  ptr array Array.append
  TokenType.CHAR  ptr array Array.append
  TokenType.INT   ptr array Array.append
  TokenType.UINT8 ptr array Array.append
  array
end

// Create Array of pointer types
// TODO: Enable creating constant arrays
// Params None
// Return
//    POINTER_TYPES: Array
function POINTER_TYPES -> ptr :
  3 Array.init
  take array in
  TokenType.ANY   ptr array Array.append
  TokenType.PTR   ptr array Array.append
  TokenType.STR   ptr array Array.append
  array
end

// Type check every sub-program in the application
// Params
//    sub_programs: List[Program]
//    functions: List[Function]
// Return None
function type_check_application ptr ptr :
  dup List.len
  0
  take
    index
    sub_programs.len
    sub_programs
    functions
  in
  while index sub_programs.len < do
    index sub_programs List.nth ptr.load
    take sub_program in

    sub_program List.first ptr.load Op.get_function
    take func in

    functions func sub_program type_check_sub_program
    index 1 + index =
  done
end

// Type check a sub-program ("function")
// Params
//    program: Program
//    func: Function
//    functions: List[Function]
// Return None
function type_check_sub_program ptr ptr ptr :
  dup List.len
  0
  take
    index
    program.len
    program
    func
    functions
  in

  // Generate initial type stack for sub program
  // based on the function params
  List.init dup
  func get_function_type_stack
  swap List.append
  List.init // List[Variable]
  take variables branched_stacks in

  // Type check every Op in Program
  while index program.len < do
    index program List.nth ptr.load
    take op in
    variables functions program branched_stacks op type_check_op
    index 1 + index =
  done
end

// Type check the current Op in the Program
// Raise compiler error if the type checking fails
// Params
//    op: Op
//    branched_stacks: List[TypeStack[TypeNode]]
//    program: Program
//    functions: List[Function]
//    variables: List[Variable]
// Return None
function type_check_op ptr ptr ptr ptr ptr :
  take
    op
    branched_stacks
    program
    functions
    variables
  in
  op  Op.get_token
  dup Token.get_value
  op  Op.get_type
  branched_stacks List.last ptr.load
  take
    type_stack
    op_type
    token_value
    token
  in

  // Switch like if block with every type of Op
  if op_type OpType.INTRINSIC == do
    type_stack token type_check_intrinsic return
  elif op_type OpType.ASSIGN_BIND == do
    variables program type_stack token type_check_assign_bind return
  elif op_type OpType.CAST_BOOL == do
    type_stack token type_check_cast_bool return
  elif op_type OpType.CAST_CHAR == do
    type_stack token type_check_cast_char return
  elif op_type OpType.CAST_INT == do
    type_stack token type_check_cast_int return
  elif op_type OpType.CAST_PTR == do
    type_stack token type_check_cast_ptr return
  elif op_type OpType.CAST_STR == do
    type_stack token type_check_cast_str return
  elif op_type OpType.CAST_UINT8 == do
    type_stack token type_check_cast_uint8 return
  elif op_type OpType.DO == do
    type_stack token type_check_do return
  elif op_type OpType.POP_BIND == do
    variables type_stack token type_check_pop_bind return
  elif op_type OpType.PUSH_BIND == do
    variables type_stack token type_check_push_bind return
  elif op_type OpType.PUSH_BOOL == do
    type_stack token type_check_push_bool return
  elif op_type OpType.PUSH_CHAR == do
    type_stack token type_check_push_char return
  elif op_type OpType.PUSH_INT == do
    type_stack token type_check_push_int return
  elif op_type OpType.PUSH_PTR == do
    type_stack token type_check_push_ptr return
  elif op_type OpType.PUSH_STR == do
    type_stack token type_check_push_str return
  elif op_type OpType.PUSH_UINT8 == do
    type_stack token type_check_push_uint8 return
  elif
    token_value str.copy str.upper
    get_not_typed_tokens
    List.contains_str
  do
    return
  endif

  // Type checking certain OpType is not implemented
  "Parsing token '"
  token_value str.cat
  "' is not implemented yet\n" str.cat
  eputs // NotImplementedError
end

// Type check an intrinsic
// Params
//    token: Token
//    type_stack: LinkedList[TypeNode]
// Return None
function type_check_intrinsic ptr ptr :
  dup Token.get_value str.copy str.upper
  take
    intrinsic
    token
    type_stack
  in

  // Switch like if block with every type of Intrinsic
  if intrinsic "ARGC" streq do
    type_stack token type_check_push_int return
  elif intrinsic "ARGV" streq do
    type_stack token type_check_push_ptr return
  elif intrinsic "DIVMOD" streq do
    type_stack token type_check_divmod return
  elif intrinsic "DROP" streq do
    type_stack token type_check_drop return
  elif intrinsic "DUP" streq do
    type_stack token type_check_dup return
  elif intrinsic "ENVP" streq do
    type_stack token type_check_push_ptr return
  elif intrinsic "LOAD_" str.startswith do
    type_stack token type_check_load return
  elif intrinsic "OVER" streq do
    type_stack token type_check_over return
  elif intrinsic "PRINT" streq do
    type_stack token type_check_print return
  elif intrinsic "ROT" streq do
    type_stack token type_check_rot return
  elif intrinsic "STORE_" str.startswith do
    type_stack token type_check_store return
  elif intrinsic "SWAP" streq do
    type_stack token type_check_swap return
  elif
    intrinsic "AND" streq
    intrinsic "OR"  streq ||
  do
    type_stack token type_check_bitwise return
  elif
    intrinsic "SHL" streq
    intrinsic "SHR" streq ||
  do
    type_stack token type_check_bitshift return
  elif
    intrinsic "MINUS" streq
    intrinsic "MUL"   streq ||
    intrinsic "PLUS"  streq ||
  do
    type_stack token type_check_calculations return
  elif
    intrinsic "EQ"  streq
    intrinsic "GE"  streq ||
    intrinsic "GT"  streq ||
    intrinsic "LE"  streq ||
    intrinsic "LT"  streq ||
    intrinsic "NE"  streq ||
  do
    type_stack token type_check_comparison return
  endif

  // Type checking certain Intrinsic is not implemented
  "Type checking for '"
  intrinsic str.cat
  "' has not been implemented." str.cat
  NotImplementedError
end

// ASSIGN_BIND assigns a value to existing Variable
// Params
//    token: Token
//    type_stack: LinkedList[TypeNode]
//    program: Program
//    variables: List[Variable]
// Return None
function type_check_assign_bind ptr ptr ptr ptr :
  take
    token
    type_stack
    program
    variables
  in

  type_stack LinkedList.pop int
  type_stack LinkedList.pop int
  take t2 t1 in

  if t2 -1 == do
    token
    "ASSIGN operation requires two values on the stack"
    "POP_FROM_EMPTY_STACK" CompilerErrorWithToken
  endif

  program t1 ptr TypeNode.get_location get_op_from_location Op.get_token
  take variable_token in

  if variable_token Token.get_vartype VarType.NONE == do
    variable_token
    "ASSIGN operation requires a variable name in the top of the stack"
    "VALUE_ERROR" CompilerErrorWithToken
  endif

  token Token.get_location
  t1 ptr TypeNode.get_type TypeNode.init
  type_stack LinkedList.push
end

// CAST_BOOL explicitely casts the top element of the stack to BOOL type.
// The top element must be an integer to be cast to BOOL.
// Params
//    token: Token
//    type_stack: LinkedList[TypeNode]
// Return None
function type_check_cast_bool ptr ptr :
  take token type_stack in
  type_stack LinkedList.pop int
  take type in

  if type -1 == do
    token "The stack is empty" "POP_FROM_EMPTY_STACK" CompilerErrorWithToken
  elif type INTEGER_TYPES Array.contains_int not do
    token
    "Only integer-like values can be cast to BOOL\nPopped type: "
    type ptr TypeNode.get_type token_type_repr str.cat
    "VALUE_ERROR" CompilerErrorWithToken
  endif

  // Push a boolean back to the stack
  token Token.get_location TokenType.BOOL TypeNode.init
  type_stack LinkedList.push
end

// CAST_CHAR explicitely casts the top element of the stack to CHAR type.
// The top element must be in INTEGER_TYPES to be cast to CHAR.
// Params
//    token: Token
//    type_stack: LinkedList[TypeNode]
// Return None
function type_check_cast_char ptr ptr :
  take token type_stack in
  type_stack LinkedList.pop int
  take type in

  if type -1 == do
    token "The stack is empty" "POP_FROM_EMPTY_STACK" CompilerErrorWithToken
  elif type TokenType.BOOL == do
    token
    "A boolean value cannot be cast to CHAR"
    "VALUE_ERROR" CompilerErrorWithToken
  elif type INTEGER_TYPES Array.contains_int not do
    token
    "Only integer-like values can be cast to CHAR\nPopped type: "
    type ptr TypeNode.get_type token_type_repr str.cat
    "VALUE_ERROR" CompilerErrorWithToken
  endif

  // Push a character back to the stack
  token Token.get_location TokenType.CHAR TypeNode.init
  type_stack LinkedList.push
end

// CAST_INT explicitely casts the top element of the stack to INT type.
// Params
//    token: Token
//    type_stack: LinkedList[TypeNode]
// Return None
function type_check_cast_int ptr ptr :
  take token type_stack in
  type_stack LinkedList.pop int
  take type in

  if type -1 == do
    token "The stack is empty" "POP_FROM_EMPTY_STACK" CompilerErrorWithToken
  endif

  // Push an integer back to the stack
  token Token.get_location TokenType.INT TypeNode.init
  type_stack LinkedList.push
end

// CAST_PTR explicitely casts the top element of the stack to PTR type.
// Params
//    token: Token
//    type_stack: LinkedList[TypeNode]
// Return None
function type_check_cast_ptr ptr ptr :
  take token type_stack in
  type_stack LinkedList.pop int
  take type in

  if type -1 == do
    token "The stack is empty" "POP_FROM_EMPTY_STACK" CompilerErrorWithToken
  elif
    type TokenType.BOOL ==
    type TokenType.CHAR ==
    ||
  do
    token
    type ptr TypeNode.get_type token_type_repr
    " cannot be cast to PTR" str.cat
    "VALUE_ERROR" CompilerErrorWithToken
  endif

  // Push a pointer back to the stack
  token Token.get_location TokenType.PTR TypeNode.init
  type_stack LinkedList.push
end

// CAST_STR explicitely casts the top element of the stack to STR type.
// Params
//    token: Token
//    type_stack: LinkedList[TypeNode]
// Return None
function type_check_cast_str ptr ptr :
  take token type_stack in
  type_stack LinkedList.pop int
  take type in

  if type -1 == do
    token "The stack is empty" "POP_FROM_EMPTY_STACK" CompilerErrorWithToken
  elif type POINTER_TYPES Array.contains_int not do
    token
    type ptr TypeNode.get_type token_type_repr
    " cannot be cast to STR" str.cat
    "VALUE_ERROR" CompilerErrorWithToken
  endif

  // Push a string back to the stack
  token Token.get_location TokenType.STR TypeNode.init
  type_stack LinkedList.push
end

// CAST_UINT8 explicitely casts the top element of the stack to UINT8 type.
// Params
//    token: Token
//    type_stack: LinkedList[TypeNode]
// Return None
function type_check_cast_uint8 ptr ptr :
  take token type_stack in
  type_stack LinkedList.pop int
  take type in

  if type -1 == do
    token "The stack is empty" "POP_FROM_EMPTY_STACK" CompilerErrorWithToken
  elif type INTEGER_TYPES Array.contains_int not do
    token
    "Only integer-like values can be cast to UINT8\nPopped type: "
    type ptr TypeNode.get_type
    token_type_repr str.cat
    "VALUE_ERROR" CompilerErrorWithToken
  endif

  // Push 8-bit unsigned integer back to the stack
  token Token.get_location TokenType.UINT8 TypeNode.init
  type_stack LinkedList.push
end

// DO Keyword pops one boolean from the stack
// Params
//    token: Token
//    type_stack: LinkedList[TypeNode]
// Return None
function type_check_do ptr ptr :
  take token type_stack in
  type_stack LinkedList.pop int
  take type in

  if type -1 == do
    token "The stack is empty" "POP_FROM_EMPTY_STACK" CompilerErrorWithToken
  elif type TokenType.BOOL != do
    token
    "DO requires a boolean\nPopped type: "
    type ptr TypeNode.get_type
    token_type_repr str.cat
    "VALUE_ERROR" CompilerErrorWithToken
  endif
end

// Pop a value from the stack to a Variable
// Params
//    token: Token
//    type_stack: LinkedList[TypeNode]
//    variables: List[Variable]
// Return None
function type_check_pop_bind ptr ptr ptr :
  take
    token
    type_stack
    variables
  in

  type_stack LinkedList.pop int
  take type in

  // Stack is empty
  if type -1 == do
    token
    "Cannot drop value from empty stack"
    "POP_FROM_EMPTY_STACK" CompilerErrorWithToken
  endif

  type token Token.get_value Variable.init
  variables List.append
end

// Push a value from Variable to the stack
// Params
//    token: Token
//    type_stack: LinkedList[TypeNode]
//    variables: List[Variable]
// Return None
function type_check_push_bind ptr ptr ptr :
  take
    token
    type_stack
    variables
  in

  token Token.get_location
  token Token.get_value variables List.get_variable Variable.get_type
  TypeNode.init type_stack LinkedList.push
end

// Push a boolean to the stack
// Params
//    token: Token
//    type_stack: LinkedList[TypeNode]
// Return None
function type_check_push_bool ptr ptr :
  Token.get_location TokenType.BOOL TypeNode.init
  swap LinkedList.push
end

// Push a character to the stack
// Params
//    token: Token
//    type_stack: LinkedList[TypeNode]
// Return None
function type_check_push_char ptr ptr :
  Token.get_location TokenType.CHAR TypeNode.init
  swap LinkedList.push
end

// Push an integer to the stack
// Params
//    token: Token
//    type_stack: LinkedList[TypeNode]
// Return None
function type_check_push_int ptr ptr :
  Token.get_location TokenType.INT TypeNode.init
  swap LinkedList.push
end

// Push a pointer to the stack
// Params
//    token: Token
//    type_stack: LinkedList[TypeNode]
// Return None
function type_check_push_ptr ptr ptr :
  Token.get_location TokenType.PTR TypeNode.init
  swap LinkedList.push
end

// Push a string to the stack
// Params
//    token: Token
//    type_stack: LinkedList[TypeNode]
// Return None
function type_check_push_str ptr ptr :
  Token.get_location TokenType.STR TypeNode.init
  swap LinkedList.push
end

// Push an unsigned 8-bit integer to the stack
// Params
//    token: Token
//    type_stack: LinkedList[TypeNode]
// Return None
function type_check_push_uint8 ptr ptr :
  Token.get_location TokenType.UINT8 TypeNode.init
  swap LinkedList.push
end

// DIVMOD pops two items from the stack and divides second from the top one.
// Then push the remainder and the quotient of the two values.
// Params
//    token: Token
//    type_stack: LinkedList[TypeNode]
// Return None
function type_check_divmod ptr ptr :
  dup Token.get_value str.copy str.upper
  take
    token_value
    token
    type_stack
  in

  // Pop two items from the stack
  type_stack LinkedList.pop int
  type_stack LinkedList.pop int
  take t2 t1 in

  // Not enough values in the stack
  if t2 -1 == do
    token
    token_value " intrinsic requires two integers" str.cat
    "POP_FROM_EMPTY_STACK" CompilerErrorWithToken
  // Wrong token type
  elif
    t1 INTEGER_TYPES Array.contains_int not
    t2 INTEGER_TYPES Array.contains_int not
    ||
  do
    token
    token_value " intrinsic requires two integers\n\n" str.cat
    "Popped types:\n" str.cat
    t1 ptr TypeNode.get_type token_type_repr str.cat "\n" str.cat
    t2 ptr TypeNode.get_type token_type_repr str.cat
    "VALUE_ERROR" CompilerErrorWithToken
  endif

  // Push the remainder and the quotient to the stack
  token Token.get_location
  take location in
  location TokenType.INT TypeNode.init type_stack LinkedList.push
  location TokenType.INT TypeNode.init type_stack LinkedList.push
end

// DROP removes one item from the stack
// Params
//    token: Token
//    type_stack: LinkedList[TypeNode]
// Return None
function type_check_drop ptr ptr :
  take token type_stack in

  // Pop one item from the stack
  type_stack LinkedList.pop int
  take type in

  // Stack is empty
  if type -1 == do
    token
    "Cannot drop value from empty stack"
    "POP_FROM_EMPTY_STACK" CompilerErrorWithToken
  endif
end

// DUP duplicates the top item from the stack
// Params
//    token: Token
//    type_stack: LinkedList[TypeNode]
// Return None
function type_check_dup ptr ptr :
  take token type_stack in

  // Pop one item from the stack
  type_stack LinkedList.pop int
  take type in

  // Stack is empty
  if type -1 == do
    token
    "Cannot duplicate value from empty stack"
    "POP_FROM_EMPTY_STACK" CompilerErrorWithToken
  endif

  // Push the popped value twice
  type ptr type_stack LinkedList.push
  type ptr type_stack LinkedList.push
end

// LOAD variants load certain type of value from where a pointer is pointing to.
// It takes one pointer from the stack and pushes back the dereferenced pointer value.
// Different LOAD variants: LOAD_BYTE, LOAD_WORD, LOAD_DWORD, LOAD_QWORD
// Params
//    token: Token
//    type_stack: LinkedList[TypeNode]
// Return None
function type_check_load ptr ptr :
  take token type_stack in

  // Pop one item from the stack
  type_stack LinkedList.pop int
  take type in

  // Stack is empty
  if type -1 == do
    token
    "The stack is empty - PTR required"
    "POP_FROM_EMPTY_STACK" CompilerErrorWithToken
  // Wrong token type
  elif type POINTER_TYPES Array.contains_int not do
    token
    dup Token.get_value str.copy str.upper
    " requires a pointer\n\n"                   str.cat
    "Popped type: "                             str.cat
    type ptr TypeNode.get_type token_type_repr  str.cat
    "VALUE_ERROR" CompilerErrorWithToken
  endif

  // Push loaded value which could be of any type
  token Token.get_location TokenType.ANY TypeNode.init
  type_stack LinkedList.push
end

// OVER Intrinsic pushes a copy of the second element of the stack.
// Example with the stack's top element being the rightmost: a b -> a b a
// Params
//    token: Token
//    type_stack: LinkedList[TypeNode]
// Return None
function type_check_over ptr ptr :
  take token type_stack in

  // Pop two items from the stack
  type_stack LinkedList.pop int
  type_stack LinkedList.pop int
  take t2 t1 in

  // Not enough values in the stack
  if t2 -1 == do
    token
    "OVER intrinsic requires two values in the stack"
    "POP_FROM_EMPTY_STACK" CompilerErrorWithToken
  endif

  // Push the values back to the stack in the correct order
  t2 ptr type_stack LinkedList.push
  t1 ptr type_stack LinkedList.push
  t2 ptr type_stack LinkedList.push
end

// Pop an integer from the stack and print its value to stdout
// Params
//    token: Token
//    type_stack: LinkedList[TypeNode]
// Return None
function type_check_print ptr ptr :
  take token type_stack in

  // Pop one item from the stack
  type_stack LinkedList.pop int
  take type in

  // Not enough values in the stack
  if type -1 == do
    token
    "Cannot print from an empty stack"
    "POP_FROM_EMPTY_STACK" CompilerErrorWithToken
  // Wrong token type
  elif type INTEGER_TYPES Array.contains_int not do
    token
    "PRINT intrinsic requires an integer\n\n"
    "Popped type: "                             str.cat
    type ptr TypeNode.get_type token_type_repr  str.cat
    "VALUE_ERROR" CompilerErrorWithToken
  endif
end

// ROT Intrinsic rotates the top three elements of the stack so that the third becomes first
// Example with the stack's top element being the rightmost: a b c -> b c a
// Params
//    token: Token
//    type_stack: LinkedList[TypeNode]
// Return None
function type_check_rot ptr ptr :
  take token type_stack in

  // Pop three items from the stack
  type_stack LinkedList.pop int
  type_stack LinkedList.pop int
  type_stack LinkedList.pop int
  take t3 t2 t1 in

  // Not enough values in the stack
  if t3 -1 == do
    token
    "ROT intrinsic requires three values in the stack"
    "POP_FROM_EMPTY_STACK" CompilerErrorWithToken
  endif

  // Push the values back to the stack in the correct order
  t2 ptr type_stack LinkedList.push
  t1 ptr type_stack LinkedList.push
  t3 ptr type_stack LinkedList.push
end

// STORE variants store a value of certain type to where a pointer is pointing to.
// It takes a pointer and a value from the stack and loads the value to the pointer address.
// Different STORE variants: STORE_BYTE, STORE_WORD, STORE_DWORD, STORE_QWORD
// Params
//    token: Token
//    type_stack: LinkedList[TypeNode]
// Return None
function type_check_store ptr ptr :
  dup Token.get_value str.copy str.upper
  " intrinsic requires two values on the stack, PTR and value" str.cat
  take
    required_values_str
    token
    type_stack
  in

  // Pop two items from the stack
  type_stack LinkedList.pop int
  type_stack LinkedList.pop int
  take t2 t1 in

  // Not enough values in the stack
  if t2 -1 == do
    token
    required_values_str
    "POP_FROM_EMPTY_STACK" CompilerErrorWithToken
  elif t1 POINTER_TYPES Array.contains_int not do
    token
    required_values_str "\n\n"                str.cat
    "Expected types:\nPTR\nANY\n\n"           str.cat
    "Popped types:\n"                         str.cat
    t1 ptr TypeNode.get_type token_type_repr  str.cat
    "\n"                                      str.cat
    t2 ptr TypeNode.get_type token_type_repr  str.cat
    "VALUE_ERROR" CompilerErrorWithToken
  endif
end

// SWAP Intrinsic swaps two top elements in the stack.
// Example with the stack's top element being the rightmost: a b -> b a
// Params
//    token: Token
//    type_stack: LinkedList[TypeNode]
// Return None
function type_check_swap ptr ptr :
  take token type_stack in

  // Pop two items from the stack
  type_stack LinkedList.pop int
  type_stack LinkedList.pop int
  take t2 t1 in

  // Not enough values in the stack
  if t2 -1 == do
    token
    "SWAP intrinsic requires two values in the stack"
    "POP_FROM_EMPTY_STACK" CompilerErrorWithToken
  endif

  // Push the values back to the stack in the correct order
  t1 ptr type_stack LinkedList.push
  t2 ptr type_stack LinkedList.push
end

// Type check bitwise operation for two integers
// Params
//    token: Token
//    type_stack: LinkedList[TypeNode]
// Return None
function type_check_bitwise ptr ptr :
  dup Token.get_value str.copy str.upper
  take
    token_value
    token
    type_stack
  in

  // Pop two items from the stack
  type_stack LinkedList.pop int
  type_stack LinkedList.pop int
  take t2 t1 in

  // Not enough values in the stack
  if t2 -1 == do
    token
    token_value " intrinsic requires two integers" str.cat
    "POP_FROM_EMPTY_STACK" CompilerErrorWithToken
  // Wrong token type
  elif
    t1 INTEGER_TYPES Array.contains_int not
    t2 INTEGER_TYPES Array.contains_int not
    ||
  do
    token
    token_value " intrinsic requires two integers\n\n" str.cat
    "Popped types:\n" str.cat
    t1 ptr TypeNode.get_type token_type_repr str.cat "\n" str.cat
    t2 ptr TypeNode.get_type token_type_repr str.cat
    "VALUE_ERROR" CompilerErrorWithToken
  endif

  // Push the result to the stack
  token Token.get_location TokenType.INT TypeNode.init
  type_stack LinkedList.push
end

// SHL performs bitshift operations to the left SHR to the right.
// The second argument is the value to be bitshifted
// and the first is the amount of times the shift should be performed.
// Params
//    token: Token
//    type_stack: LinkedList[TypeNode]
// Return None
function type_check_bitshift ptr ptr :
  dup Token.get_value str.copy str.upper
  take
    token_value
    token
    type_stack
  in

  // Pop two items from the stack
  type_stack LinkedList.pop int
  type_stack LinkedList.pop int
  take t2 t1 in

  // Not enough values in the stack
  if t2 -1 == do
    token
    token_value " intrinsic requires two values in the stack" str.cat
    "POP_FROM_EMPTY_STACK" CompilerErrorWithToken
  // Wrong token type
  elif
    t1 INTEGER_TYPES Array.contains_int not
    t2 INTEGER_TYPES Array.contains_int not
    ||
  do
    token
    token_value " intrinsic requires two integers\n\n" str.cat
    "Popped types:\n" str.cat
    t1 ptr TypeNode.get_type token_type_repr str.cat "\n" str.cat
    t2 ptr TypeNode.get_type token_type_repr str.cat
    "VALUE_ERROR" CompilerErrorWithToken
  endif

  // Push the result to the stack
  token Token.get_location TokenType.INT TypeNode.init
  type_stack LinkedList.push
end

// Type check calculation intrinsics MINUS, MUL, and PLUS
// Params
//    token: Token
//    type_stack: LinkedList[TypeNode]
// Return None
function type_check_calculations ptr ptr :
  dup Token.get_value str.copy str.upper
  take
    token_value
    token
    type_stack
  in

  // Pop two items from the stack
  type_stack LinkedList.pop int
  type_stack LinkedList.pop int
  take t2 t1 in

  // Not enough values in the stack
  if t2 -1 == do
    token
    token_value " requires two values on the stack" str.cat
    "POP_FROM_EMPTY_STACK" CompilerErrorWithToken
  // Wrong token type
  elif
    t1 INTEGER_TYPES Array.contains_int not
    t2 INTEGER_TYPES Array.contains_int not
    ||
  do
    token
    token_value " intrinsic requires two integers\n\n" str.cat
    "Popped types:\n" str.cat
    t1 ptr TypeNode.get_type token_type_repr str.cat "\n" str.cat
    t2 ptr TypeNode.get_type token_type_repr str.cat
    "VALUE_ERROR" CompilerErrorWithToken
  endif

  // Push the result to the stack
  token Token.get_location TokenType.INT TypeNode.init
  type_stack LinkedList.push
end

// Type check comparison intrinsics like EQ or GE.
// Comparison intrinsics take two elements from the stack
// and pushes a boolean result of the comparison.
// Params
//    token: Token
//    type_stack: LinkedList[TypeNode]
// Return None
function type_check_comparison ptr ptr :
  dup Token.get_value str.copy str.upper
  take
    token_value
    token
    type_stack
  in

  // Pop two items from the stack
  type_stack LinkedList.pop int
  type_stack LinkedList.pop int
  take t2 t1 in

  // Not enough values in the stack
  if t2 -1 == do
    token
    token_value " requires two values on the stack" str.cat
    "POP_FROM_EMPTY_STACK" CompilerErrorWithToken
  // Wrong token type
  elif
    t1 INTEGER_TYPES Array.contains_int not
    t2 INTEGER_TYPES Array.contains_int not
    ||
  do
    token
    token_value " intrinsic requires two integers\n\n" str.cat
    "Popped types:\n" str.cat
    t1 ptr TypeNode.get_type token_type_repr str.cat "\n" str.cat
    t2 ptr TypeNode.get_type token_type_repr str.cat
    "VALUE_ERROR" CompilerErrorWithToken
  endif

  // Push the result to the stack
  token Token.get_location TokenType.BOOL TypeNode.init
  type_stack LinkedList.push
end

// Get a list of tokens that do not require type checking
// TODO: This list should be a constant somehow
// Params
//    op: Op
// Return None
function get_not_typed_tokens -> ptr :
  // ["BREAK", "CONTINUE", "PEEK", "TAKE", "WHILE"]
  List.init take not_typed_tokens in
  "BREAK"     ptr not_typed_tokens List.append
  "CONTINUE"  ptr not_typed_tokens List.append
  "PEEK"      ptr not_typed_tokens List.append
  "TAKE"      ptr not_typed_tokens List.append
  "WHILE"     ptr not_typed_tokens List.append
  not_typed_tokens
end

// Generate TypeStack for a function
// Params
//    func: Function
// Return
//    type_stack: LinkedList[TypeNode]
function get_function_type_stack ptr -> ptr :
  take func in
  func Function.get_signature Signature.get_params
  dup List.len 1 -
  LinkedList.init
  take
    type_stack
    index
    params
  in

  // Get the first Token's location for TypeNodes
  func Function.get_tokens List.first ptr.load Token.get_location
  take location in

  // Insert all parameter types to type_stack in the reverse order
  while index 0 >= do
    // Add TypeNode from current parameter to type_stack
    location
    index params List.nth ptr.load int
    TypeNode.init
    type_stack LinkedList.push
    index 1 - index =
  done
  type_stack
end
