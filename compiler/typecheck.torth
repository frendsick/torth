include "std"
include "compiler/class/Op"
include "compiler/class/Token"

// Type check every sub-program in the application
// Params
//    sub_programs: List[Program]
//    functions: List[Function]
// Return None
function type_check_application ptr ptr :
  dup List.len
  0
  take
    index
    sub_programs.len
    sub_programs
    functions
  in
  while index sub_programs.len < do
    index sub_programs List.nth ptr.load
    take sub_program in

    sub_program List.first ptr.load Op.get_function
    take func in

    functions func sub_program type_check_sub_program
    index 1 + index =
  done
end

// Type check a sub-program ("function")
// Params
//    program: Program
//    func: Function
//    functions: List[Function]
// Return None
function type_check_sub_program ptr ptr ptr :
  dup List.len
  0
  take
    index
    program.len
    program
    func
    functions
  in
  // Generate initial type stack for sub program
  // based on the function params
  List.init dup
  func get_function_type_stack
  swap List.append
  take branched_stacks in

  // Type check every Op in Program
  while index program.len < do
    index program List.nth ptr.load
    take op in
    functions program branched_stacks op type_check_op
    index 1 + index =
  done
end

// Type check the current Op in the Program
// Raise compiler error if the type checking fails
// Params
//    op: Op
//    branched_stacks: List[TypeStack]
//    program: Program
//    functions: List[Function]
// Return None
function type_check_op ptr ptr ptr ptr :
  take
    op
    branched_stacks
    program
    functions
  in
  op  Op.get_token
  dup Token.get_value
  op  Op.get_type
  branched_stacks List.last ptr.load
  take
    type_stack
    op_type
    token_value
    token
  in

  // Switch like if block with every type of Op
  if op_type OpType.INTRINSIC == do
    token type_check_intrinsic
  elif op_type OpType.PUSH_INT == do
    type_stack type_check_push_int
  elif
    token_value str.upper
    get_not_typed_tokens
    List.contains_str
  do
    token_value puts "\n" puts
    0 exit
    return
  else
    "Parsing token '"
    token_value str.cat
    "' is not implemented yet" str.cat
    NotImplementedError
  endif
end

// Push an integer to the stack
// Params
//    type_stack: LinkedList
// Return None
function type_check_push_int ptr :
  TokenType.INT ptr swap LinkedList.push
end

// Type check an intrinsic
// Params
//    token: Token
// Return None
function type_check_intrinsic ptr :
  dup Token.get_value str.upper
  take intrinsic token in

  "Type checking for '"
  intrinsic str.cat
  "' has not been implemented." str.cat
  NotImplementedError
end

// Get a list of tokens that do not require type checking
// TODO: This list should be a constant somehow
// Params
//    op: Op
// Return None
function get_not_typed_tokens -> ptr :
  // ["BREAK", "CONTINUE", "PEEK", "TAKE", "WHILE"]
  List.init take not_typed_tokens in
  "BREAK"     ptr not_typed_tokens List.append
  "CONTINUE"  ptr not_typed_tokens List.append
  "PEEK"      ptr not_typed_tokens List.append
  "TAKE"      ptr not_typed_tokens List.append
  "WHILE"     ptr not_typed_tokens List.append
  not_typed_tokens
end

// Generate TypeStack for a function
// Params
//    func: Function
// Return
//    type_stack: LinkedList
function get_function_type_stack ptr -> ptr :
  take func in
  func Function.get_signature Signature.get_params
  dup List.len 1 -
  LinkedList.init
  take
    type_stack
    index
    params
  in

  // Insert all parameter types to type_stack in the reverse order
  while index 0 >= do
    // Push the current parameters TokenType to type_stack
    index params List.nth ptr.load
    type_stack LinkedList.push
    index 1 - index =
  done
  type_stack
end
