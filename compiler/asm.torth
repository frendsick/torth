include "std"
include "compiler/utils"
include "compiler/class/Op"

function initialize_asm -> str :
  "compiler/templates/torth_template.asm" read_file
end

// Get Assembly for certain Op
// Params: Pointer to Op (PTR)
// Return: Assembly
function get_op_asm ptr -> str :
  // Save Op and Token.value in Binding
  dup  Op.get_token Token.get_value
  over Op.get_type
  take op_type token_value op in

  // Get assembly for the correct OpType
  if op_type OpType.FUNCTION_CALL == do
    token_value get_function_call_asm
    return
  elif op_type OpType.PUSH_BOOL == do
    token_value str.upper get_push_bool_asm
    return
  elif op_type OpType.PUSH_CHAR == do
    token_value 1 str.char_at get_push_char_asm
    return
  elif op_type OpType.PUSH_INT == do
    token_value get_push_int_asm
    return
  elif op_type OpType.PUSH_STR == do
    "TODO: Generating assembly for OpType.PUSH_STR is not implemented yet.\n"
    "" swap NotImplementedError
  elif op_type OpType.PUSH_PTR == do
    token_value get_push_ptr_asm
    return
  elif op_type OpType.INTRINSIC == do
    // Get assembly for correct Intrinsic
    token_value str.upper
    take intrinsic in
    if intrinsic "AND" streq do
      get_and_asm return
    elif intrinsic "PLUS" streq do
      get_plus_asm return
    elif intrinsic "PRINT" streq do
      get_print_asm return
    else
      "Generating assembly for intrinsic '" intrinsic str.cat
      "' is not implemented yet\n" str.cat
      "" swap NotImplementedError
    endif
  else
    "Generating assembly for '" token_value str.cat
    "' is not implemented: Unknown word\n" str.cat
    "" swap NotImplementedError
  endif
end

// Get Assembly comment for Op
// Params: Pointer to Op (PTR)
// Return: Comment string (STR)
function get_op_comment_asm ptr -> str :
  take op in
  // Comment format as Python3 f-string:
  // f";; [{function_name}] {token_value} | File: {file}, Row: {row}, Col: {col}\n"
  ";; ["
  op Op.get_function Function.get_name  str.cat
  "] "                                  str.cat
  op Op.get_token Token.get_value       str.cat
  " | File: "                           str.cat

  op Op.get_token Token.get_location
  take token_loc in

  // Add file, row and column information
  token_loc Location.get_file           str.cat
  ", Row: "                             str.cat
  token_loc Location.get_row itoa       str.cat
  ", Column: "                          str.cat
  token_loc Location.get_column itoa    str.cat
  "\n"                                  str.cat
end

function get_function_call_asm str -> str :
  "  call "
  swap str.cat
  "\n" str.cat
end

// Generate Assembly for OpType.PUSH_BOOL
// Params: Op.token.value
// Return: Assembly
function get_push_bool_asm str -> str :
  if dup "TRUE" streq
  do drop   "  mov rax, 1\n"
  else drop "  mov rax, 0\n"
  endif     "  push rax\n" str.cat
end

// Generate Assembly for OpType.PUSH_CHAR
// Params: Op.token.value[1] ('a' => a)
// Return: Assembly
function get_push_char_asm char -> str :
  int itoa
  "  mov rax, " swap  str.cat
  "\n  push rax\n"    str.cat
end

// Generate Assembly for OpType.PUSH_INT
// Params: Op.token.value
// Return: Assembly
function get_push_int_asm str -> str :
  "  mov rax, " swap  str.cat
  "\n  push rax\n"    str.cat
end

// Generate Assembly for OpType.PUSH_PTR
// Params: Op.token.value
// Return: Assembly
function get_push_ptr_asm str -> str :
  "  mov rax, " swap  str.cat
  "\n  push rax\n"    str.cat
end

// AND performs bitwise-AND operation to two integers
// Params: None
// Return: Assembly
function get_and_asm -> str :
  "  pop rax\n"
  "  pop rbx\n"       str.cat
  "  and rbx, rax\n"  str.cat
  "  push rbx\n"      str.cat
end

// Pop two integers from the stack and push the sum of the two values
// Params: None
// Return: Assembly
function get_plus_asm -> str :
  "  pop rbx\n"
  "  pop rax\n"       str.cat
  "  add rax, rbx\n"  str.cat
  "  push rax\n"      str.cat
end

// Pop an integer from the stack and print the value of it to the stdout
// Params: None
// Return: Assembly
function get_print_asm -> str :
  "  pop rdi\n"
  "  call print\n"    str.cat
end

function get_exit_assembly -> str :
  ";; -- exit syscall\n"
  "  mov rax, sys_exit\n" str.cat
  "  mov rdi, 0\n"           str.cat
  "  syscall\n"         str.cat
end

// Generate assembly code for NASM
// Params: sub_programs (List[Program])
// Return: Intel x86_64 Assembly for NASM (STR)
function generate_assembly_code ptr -> str :
  dup list.len
  initialize_asm
  0
  take
    index
    assembly_code
    sub_programs.len
    sub_programs
  in

  // Iterate over each Program in sub_programs
  while index sub_programs.len < do

    // Get the current Program
    sub_programs list.first
    index ptr.size * ptr+ ptr.load

    // Get assembly code for the current Program
    get_programs_assembly_code

    // Concatenate the Program's assembly to assembly_code
    assembly_code swap str.cat
    assembly_code =
    index 1 + index = // index++
  done

  // Get assembly for exiting the program
  assembly_code get_exit_assembly str.cat
end

function get_programs_assembly_code ptr -> str :
  dup list.len
  "" str.copy
  0
  take
    index
    assembly_code
    program.len
    program
  in

  // Generate assembly for each Op in Program
  while index program.len < do
    // Get the current Op
    program list.first
    index ptr.size * ptr+ ptr.load
    take op in

    // Generate comment for Op
    assembly_code op get_op_comment_asm str.cat

    // Concatenate Op's Assembly to op_asm
    op get_op_asm str.cat
    assembly_code =
    index 1 + index =
  done
  assembly_code
end