include "std"
include "compiler/utils"
include "compiler/class/Op"

function initialize_asm -> str :
  "compiler/templates/torth_template.asm" read_file
end

// Get Assembly for certain Op
// Params: Pointer to Op (PTR)
// Return: Assembly
function get_op_asm ptr -> str :
  // Save Op and Token.value in Binding
  dup  Op.get_token Token.get_value
  over Op.get_type
  take op_type token_value op in

  // Get assembly for the correct OpType
  if
    op_type OpType.CAST_BOOL ==
    op_type OpType.CAST_CHAR ==   ||
    op_type OpType.CAST_INT ==    ||
    op_type OpType.CAST_PTR ==    ||
    op_type OpType.CAST_STR ==    ||
    op_type OpType.CAST_UINT8 ==  ||
    op_type OpType.IF ==          ||
    op_type OpType.IN ==          ||
    op_type OpType.TAKE ==        ||
  do
    "" return
  elif op_type OpType.FUNCTION_CALL == do
    token_value get_function_call_asm
    return
  elif op_type OpType.PEEK == do
    get_peek_asm
    return
  elif op_type OpType.PEEK_BIND == do
    op get_peek_bind_asm
    return
  elif op_type OpType.POP_BIND == do
    op get_pop_bind_asm
    return
  elif op_type OpType.PUSH_BIND == do
    op get_push_bind_asm
    return
  elif op_type OpType.PUSH_BOOL == do
    token_value str.upper get_push_bool_asm
    return
  elif op_type OpType.PUSH_CHAR == do
    token_value 1 str.char_at get_push_char_asm
    return
  elif op_type OpType.PUSH_INT == do
    token_value get_push_int_asm
    return
  elif op_type OpType.PUSH_PTR == do
    token_value get_push_ptr_asm
    return
  elif op_type OpType.PUSH_STR == do
    op get_push_str_asm
    return
  elif op_type OpType.RETURN == do
    op Op.get_function Function.get_name get_return_asm
    return
  elif op_type OpType.WHILE == do
    op get_while_asm
    return
  elif op_type OpType.INTRINSIC == do
    // Get assembly for correct Intrinsic
    token_value str.copy str.upper
    take intrinsic in
    if intrinsic "AND" streq do
      get_and_asm return
    elif intrinsic "ARGC" streq do
      get_argc_asm return
    elif intrinsic "ARGV" streq do
      get_argv_asm return
    elif intrinsic "DIVMOD" streq do
      get_divmod_asm return
    elif intrinsic "DROP" streq do
      get_drop_asm return
    elif intrinsic "DUP" streq do
      get_dup_asm return
    elif intrinsic "ENVP" streq do
      get_envp_asm return
    elif intrinsic "EQ" streq do
      get_eq_asm return
    elif intrinsic "GE" streq do
      get_ge_asm return
    elif intrinsic "GT" streq do
      get_ge_asm return
    elif intrinsic "LE" streq do
      get_le_asm return
    elif intrinsic "LT" streq do
      get_lt_asm return
    elif intrinsic "LOAD_" str.startswith do
      intrinsic get_load_asm
    elif intrinsic "MINUS" streq do
        get_minus_asm return
    elif intrinsic "MUL" streq do
      get_mul_asm return
    elif intrinsic "NE" streq do
      get_ne_asm return
    elif intrinsic "NTH" streq do
      get_nth_asm return
    elif intrinsic "PLUS" streq do
      get_plus_asm return
    elif intrinsic "PRINT" streq do
      get_print_asm return
    elif intrinsic "STORE_" str.startswith do
      intrinsic get_store_asm
    else
      "Generating assembly for intrinsic '" intrinsic str.cat
      "' is not implemented yet\n" str.cat
      "" swap NotImplementedError
    endif
  else
    "Generating assembly for '" token_value str.cat
    "' is not implemented: Unknown word\n" str.cat
    "" swap NotImplementedError
  endif
end

// Get Assembly comment for Op
// Params: Pointer to Op (PTR)
// Return: Comment string (STR)
function get_op_comment_asm ptr -> str :
  take op in
  // Comment format as Python3 f-string:
  // f";; [{function_name}] {token_value} | File: {file}, Row: {row}, Col: {col}\n"
  ";; ["
  op Op.get_function Function.get_name  str.cat
  "] "                                  str.cat
  op Op.get_token Token.get_value       str.cat
  " | File: "                           str.cat

  op Op.get_token Token.get_location
  take token_loc in

  // Add file, row and column information
  token_loc Location.get_file           str.cat
  ", Row: "                             str.cat
  token_loc Location.get_row itoa       str.cat
  ", Column: "                          str.cat
  token_loc Location.get_column itoa    str.cat
  "\n"                                  str.cat
end

function get_function_call_asm str -> str :
  "  call "
  swap str.cat
  "\n" str.cat
end

// Generate Assembly for OpType.PUSH_BOOL
// Params: Op.token.value
// Return: Assembly
function get_push_bool_asm str -> str :
  if dup "TRUE" streq
  do drop   "  mov rax, 1\n"
  else drop "  mov rax, 0\n"
  endif     "  push rax\n" str.cat
end

// Generate Assembly for OpType.PEEK
// Params: None
// Return: Assembly
function get_peek_asm -> str :
  // Save current stack pointer to r15
  "  mov r15, rsp\n"
end

// Generate Assembly for OpType.PEEK_BIND
// Params: Op
// Return: Assembly
function get_peek_bind_asm ptr -> str :
  get_bound_memory
  "  mov rax, [r15]\n"
  "  mov ["         str.cat
  swap              str.cat
  "], rax\n"        str.cat
  "  add r15, 8\n"  str.cat
end

// Generate Assembly for OpType.POP_BIND
// Params: Op
// Return: Assembly
function get_pop_bind_asm ptr -> str :
  get_bound_memory
  "  pop qword ["
  swap  str.cat
  "]\n" str.cat
end

// Generate Assembly for OpType.POP_BIND
// Params: Op
// Return: Assembly
function get_push_bind_asm ptr -> str :
  get_bound_memory
  "  push qword ["
  swap  str.cat
  "]\n" str.cat
end

// Generate Assembly for OpType.PUSH_CHAR
// Params: Op.token.value[1] ('a' => a)
// Return: Assembly
function get_push_char_asm char -> str :
  int itoa
  "  mov rax, " swap  str.cat
  "\n  push rax\n"    str.cat
end

// Generate Assembly for OpType.PUSH_INT
// Params: Op.token.value
// Return: Assembly
function get_push_int_asm str -> str :
  "  mov rax, " swap  str.cat
  "\n  push rax\n"    str.cat
end

// Generate Assembly for OpType.PUSH_PTR
// Params: Op.token.value
// Return: Assembly
function get_push_ptr_asm str -> str :
  "  mov rax, " swap  str.cat
  "\n  push rax\n"    str.cat
end

// Generate Assembly for OpType.PUSH_STR
// Params: Op
// Return: Assembly
function get_push_str_asm ptr -> str :
  // Initialize variables
  dup   Op.get_id itoa
  swap  Op.get_function Function.get_name
  take
    function_name
    op_id
  in

  "  mov rsi, "
  function_name             str.cat
  "_s"                      str.cat
  op_id                     str.cat
  " ; Pointer to string\n"  str.cat
  "  push rsi\n"            str.cat
end

// Generate Assembly for OpType.RETURN
// Params: Function.name
// Return: Assembly
function get_return_asm str -> str :
  if dup str.copy str.upper "MAIN" streq do
    "0"   get_push_int_asm
    swap  get_function_end_asm str.cat
    return
  endif
  get_function_end_asm
end

// Generate Assembly for OpType.WHILE
// Params: Op
// Return: Assembly
function get_while_asm ptr -> str :
  // Initialize variables
  dup   Op.get_id itoa
  swap  Op.get_function Function.get_name
  take
    function_name
    op_id
  in

  function_name
  "_WHILE"  str.cat
  op_id     str.cat
  ":\n"     str.cat
end

// Return the assembly code for arithmetic Intrinsics (PLUS, MINUS, MUL)
// Params: operand
// Return: Assembly
function get_arithmetic_asm str -> str :
  take operand in
  "  pop rbx\n"
  "  pop rax\n  " str.cat
  operand         str.cat
  " rax, rbx\n"   str.cat
  "  push rax\n"  str.cat
end

// Generate assembly code for different comparison Intrinsics, like EQ and GE.
// Only the cmov operand changes with different comparison intrinsics.
// Params: cmov_operand
// Return: Assembly
function get_comparison_asm str -> str :
  "  pop rax\n"
  "  pop rbx\n"         str.cat
  "  mov rcx, 0\n"      str.cat
  "  mov rdx, 1\n"      str.cat
  "  cmp rbx, rax\n  "  str.cat
  swap                  str.cat // cmov_operand
  " rcx, rdx\n"         str.cat
  "  push rcx\n"        str.cat
end

// AND performs bitwise-AND operation to two integers
// Params: None
// Return: Assembly
function get_and_asm -> str :
  "  pop rax\n"
  "  pop rbx\n"       str.cat
  "  and rbx, rax\n"  str.cat
  "  push rbx\n"      str.cat
end

// ARGC pushes the argument count to the stack
// Params: None
// Return: Assembly
function get_argc_asm -> str :
  "  mov rax, [args_ptr]\n"
  "  mov rax, [rax]\n"  str.cat
  "  push rax\n"        str.cat
end

// ARGV pushes the pointer to argument array to the stack
// Params: None
// Return: Assembly
function get_argv_asm -> str :
  "  mov rax, [args_ptr]\n"
  "  add rax, 8\n"  str.cat
  "  push rax\n"    str.cat
end

// DIVMOD pops two integers from the stack and pushes their remainder and quotient
// Params: None
// Return: Assembly
function get_divmod_asm -> str :
  "  xor edx, edx ; Do not use floating point arithmetic\n"
  "  pop rbx\n"               str.cat
  "  pop rax\n"               str.cat
  "  div rbx\n"               str.cat
  "  push rdx ; Remainder\n"  str.cat
  "  push rax ; Quotient\n"   str.cat
end

// DROP removes one item from the stack
// Params: None
// Return: Assembly
function get_drop_asm -> str :
  "  add rsp, 8\n"
end

// DUP duplicates the top element in the stack
// Params: None
// Return: Assembly
function get_dup_asm -> str :
  "  pop rax\n"
  "  push rax\n" str.cat
  "  push rax\n" str.cat
end

// ENVP pushes the environment pointer to the stack
// Params: None
// Return: Assembly
function get_envp_asm -> str :
  "  mov rax, [args_ptr]\n"
  "  add rax, 24\n" str.cat
  "  push rax\n"    str.cat
end

// EQ takes two elements from the stack and checks if they are equal.
// Then it pushes the boolean value of the comparison.
// Params: None
// Return: Assembly
function get_eq_asm -> str :
  "cmove" get_comparison_asm
end

// GE takes two items from the stack and checks if the second item >= the other.
// Then it pushes the boolean value of the comparison.
// Params: None
// Return: Assembly
function get_ge_asm -> str :
  "cmovge" get_comparison_asm
end

// GT takes two items from the stack and checks if the second item > the other.
// Then it pushes the boolean value of the comparison.
// Params: None
// Return: Assembly
function get_gt_asm -> str :
  "cmovg" get_comparison_asm
end

// LE takes two items from the stack and checks if the second item <= the other.
// Then it pushes the boolean value of the comparison.
// Params: None
// Return: Assembly
function get_le_asm -> str :
  "cmovle" get_comparison_asm
end

// LT takes two items from the stack and checks if the second item < the other.
// Then it pushes the boolean value of the comparison.
// Params: None
// Return: Assembly
function get_lt_asm -> str :
  "cmovl" get_comparison_asm
end

// Params: load_variant
// Return: Assembly
function get_load_asm str -> str :
  str.copy str.upper
  take load_variant in

  // Get the correct size register for the load_variant
  if    load_variant "LOAD_BYTE"  streq do "bl"
  elif  load_variant "LOAD_WORD"  streq do "bx"
  elif  load_variant "LOAD_DWORD" streq do "ebx"
  elif  load_variant "LOAD_QWORD" streq do "rbx"
  else
    "'" load_variant                  str.cat
    "' is not a valid LOAD Intrinsic" str.cat
    "VALUE_ERROR" CompilerError ""
  endif
  take register in

  // Generate assembly
  "  pop rax\n"
  "  xor rbx, rbx\n"  str.cat
  "  mov "            str.cat
  register            str.cat
  ", [rax]\n"         str.cat
  "  push rbx\n"      str.cat
  dup puts
end

// Pop two integers from the stack and decrement the second value from the top one
function get_minus_asm -> str :
  "sub" get_arithmetic_asm
end

// Pop two integers from the stack and push the product of the two values
// Params: None
// Return: Assembly
function get_mul_asm -> str :
  "  pop rax\n"
  "  pop rbx\n"             str.cat
  "  mul rbx\n"             str.cat
  "  push rax  ; Product\n" str.cat
end

// NE takes two items from the stack and checks if they are not equal.
// Then it pushes the boolean value of the comparison.
// Params: None
// Return: Assembly
function get_ne_asm -> str :
  "cmovne" get_comparison_asm
end

function get_nth_asm -> str :
  "  pop rax\n"
  "  sub rax, 1\n"                                      str.cat
  "  mov rbx, 8\n"                                      str.cat
  "  mul rbx\n"                                         str.cat
  "  add rsp, rax ; Stack pointer to the Nth element\n" str.cat
  "  pop rbx      ; Get Nth element to rax\n"           str.cat
  "  add rax, 8\n"                                      str.cat
  "  sub rsp, rax ; Return stack pointer\n"             str.cat
  "  push rbx\n"                                        str.cat
end

// Pop two integers from the stack and push the sum of the two values
// Params: None
// Return: Assembly
function get_plus_asm -> str :
  "add" get_arithmetic_asm
end

// Pop an integer from the stack and print the value of it to the stdout
// Params: None
// Return: Assembly
function get_print_asm -> str :
  "  pop rdi\n"
  "  call print\n"    str.cat
end

// Params: store_variant
// Return: Assembly
function get_store_asm str -> str :
  str.copy str.upper
  take store_variant in

  // Get the correct size register for the store_variant
  if    store_variant "STORE_BYTE"  streq do "bl"
  elif  store_variant "STORE_WORD"  streq do "bx"
  elif  store_variant "STORE_DWORD" streq do "ebx"
  elif  store_variant "STORE_QWORD" streq do "rbx"
  else
    "'" store_variant                  str.cat
    "' is not a valid STORE Intrinsic" str.cat
    "VALUE_ERROR" CompilerError ""
  endif
  take register in

  // Generate assembly
  "  pop rax\n"
  "  pop rbx\n"   str.cat
  "  mov [rax], " str.cat
  register        str.cat
  "\n"            str.cat
end

function get_exit_assembly -> str :
  ";; -- exit syscall\n"
  "  mov rax, sys_exit\n" str.cat
  "  pop rdi\n"           str.cat
  "  syscall\n\n"         str.cat
end

// Generate assembly code for NASM
// Params: sub_programs (List[Program])
// Return: Intel x86_64 Assembly for NASM (STR)
function generate_assembly_code ptr -> str :
  dup list.len
  initialize_asm
  0
  take
    index
    assembly_code
    sub_programs.len
    sub_programs
  in

  // Iterate over each Program in sub_programs
  while index sub_programs.len < do

    // Get the current Program
    sub_programs list.first
    index ptr.size * ptr+ ptr.load

    // Get assembly code for the current Program
    get_programs_assembly_code

    // Concatenate the Program's assembly to assembly_code
    assembly_code swap str.cat
    assembly_code =
    index 1 + index = // index++
  done
  assembly_code
end

// Return the beginning of the assembly code of each Program
// Params: Function's name
// Return: Assembly code
function get_function_start_asm str -> str :
  take function_name in

  // MAIN Function differs from the others
  if function_name str.copy str.upper "MAIN" streq do
    "global _start\n"
    "_start:\n"                                                           str.cat
    "  mov [args_ptr], rsp   ; Pointer to argc\n"                         str.cat
    return
  endif

  function_name
  ":\n;; ["                                                               str.cat
  function_name                                                           str.cat
  "] Save the return address to return_stack\n"                           str.cat
  "  mov rax, return_stack\n"                                             str.cat
  "  add rax, [return_stack_index]\n"                                     str.cat
  "  pop qword [rax]\n"                                                   str.cat
  "  add qword [return_stack_index], 8  ; Increment return_stack_index\n" str.cat
end

// Return the end of the assembly code of each Program
// Params: Function's name
// Return: Assembly code
function get_function_end_asm str -> str :
  take function_name in

  // MAIN Function differs from the others
  if function_name str.copy str.upper "MAIN" streq do
    get_exit_assembly return
  endif

  ";; ["
  function_name                                                           str.cat
  "] Return to the address found in return_stack\n"                       str.cat
  "  sub qword [return_stack_index], 8  ; Decrement return_stack_index\n" str.cat
  "  mov rax, return_stack\n"                                             str.cat
  "  add rax, [return_stack_index]\n"                                     str.cat
  "  push qword [rax]\n"                                                  str.cat
  "  ret\n\n"                                                             str.cat
end

function get_programs_assembly_code ptr -> str :
  dup list.len
  "" str.copy
  0
  take
    index
    assembly_code
    program.len
    program
  in

  // Generate assembly for each Op in Program
  while index program.len < do
    // Get the current Op
    program list.first
    index ptr.size * ptr+ ptr.load
    take op in

    // Generate comment for Op
    assembly_code op get_op_comment_asm str.cat

    // Concatenate Op's Assembly to op_asm
    op get_op_asm str.cat
    assembly_code =
    index 1 + index =
  done

  // Get the Function's name to be added to the assembly code
  // Exception: MAIN Function should be named '_start'
  op Op.get_function Function.get_name
  take function_name in

  // Prepend the Function's beginning code and prepend the ending code
  function_name get_function_start_asm
  assembly_code str.cat
  function_name get_function_end_asm str.cat
end

// Get memory name for assembly used by a bound memory
// Params: Op
// Return: bound_memory
function get_bound_memory ptr -> str :
  // bound_memory = f"{op.func.name}_{memory_name}"
  take op in
  op Op.get_token     Token.get_value
  op Op.get_function  Function.get_name
  "_" str.cat swap str.cat
end
