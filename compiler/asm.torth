include "std"
include "compiler/utils"
include "compiler/class/Op"

// Generate the beginning of the assembly file
// Params: List[Memory]
// Return: Assembly
function initialize_asm ptr -> str :
  take memories in
  "compiler/templates/start.asm" read_file
  memories get_memory_definitions_asm       str.cat
  "compiler/templates/print.asm" read_file  str.cat
end

// Generate assembly code from Memory definitions
function get_memory_definitions_asm ptr -> str :
  "" str.copy
  0
  take
    index
    assembly_code
    memories
  in

  // Iterate over each Memory and generate assembly code for it
  while index memories list.len < do

    // Get the Memory's name and size
    index memories list.nth ptr.load
    dup   Memory.get_name
    swap  Memory.get_size
    take
      memory_size
      memory_name
    in


    // Append current Memory to assembly_code
    assembly_code
    "  "              str.cat
    memory_name       str.cat
    ": RESB "         str.cat
    memory_size itoa  str.cat
    "\n"              str.cat
    assembly_code =
    index 1 + index = // index++
  done
  assembly_code "\n"  str.cat
end

// Get Assembly for certain Op
// Params: Pointer to Op (PTR), Program
// Return: Assembly
function get_op_asm ptr ptr -> str :
  // Save Op and Token.value in Binding
  dup  Op.get_token Token.get_value
  over Op.get_type
  take
    op_type
    token_value
    op
    program
  in

  // Get assembly for the correct OpType
  if
    op_type OpType.CAST_BOOL ==
    op_type OpType.CAST_CHAR ==   ||
    op_type OpType.CAST_INT ==    ||
    op_type OpType.CAST_PTR ==    ||
    op_type OpType.CAST_STR ==    ||
    op_type OpType.CAST_UINT8 ==  ||
    op_type OpType.IF ==          ||
    op_type OpType.IN ==          ||
    op_type OpType.TAKE ==        ||
  do
    "" return
  elif op_type OpType.ASSIGN_BIND == do
    program op get_assign_bind_asm
    return
  elif op_type OpType.BREAK == do
    program op get_break_asm
    return
  elif op_type OpType.CONTINUE == do
    program op get_continue_asm
    return
  elif op_type OpType.DO == do
    program op get_do_asm
    return
  elif op_type OpType.DONE == do
    program op get_done_asm
    return
  elif op_type OpType.ELIF == do
    program op get_elif_asm
    return
  elif op_type OpType.ELSE == do
    program op get_else_asm
    return
  elif op_type OpType.ENDIF == do
    op get_endif_asm
    return
  elif op_type OpType.FUNCTION_CALL == do
    token_value get_function_call_asm
    return
  elif op_type OpType.PEEK == do
    get_peek_asm
    return
  elif op_type OpType.PEEK_BIND == do
    op get_peek_bind_asm
    return
  elif op_type OpType.POP_BIND == do
    op get_pop_bind_asm
    return
  elif op_type OpType.PUSH_BIND == do
    op get_push_bind_asm
    return
  elif op_type OpType.PUSH_BOOL == do
    token_value str.upper get_push_bool_asm
    return
  elif op_type OpType.PUSH_CHAR == do
    token_value 1 str.char_at get_push_char_asm
    return
  elif op_type OpType.PUSH_INT == do
    token_value get_push_int_asm
    return
  elif op_type OpType.PUSH_PTR == do
    token_value get_push_ptr_asm
    return
  elif op_type OpType.PUSH_STR == do
    op get_push_str_asm
    return
  elif op_type OpType.RETURN == do
    op Op.get_function Function.get_name get_return_asm
    return
  elif op_type OpType.WHILE == do
    op get_while_asm
    return
  elif op_type OpType.INTRINSIC == do
    token_value get_intrinsic_asm
    return
  else
    "Generating assembly for '" token_value str.cat
    "' is not implemented: Unknown word\n" str.cat
    "" swap NotImplementedError
  endif
end

// Get assembly code for certain Intrinsic
// Params: Token.value
// Return: Assembly
function get_intrinsic_asm str -> str :
  str.copy str.upper
  take intrinsic in
  if intrinsic "AND" streq do
    get_and_asm return
  elif intrinsic "ARGC" streq do
    get_argc_asm return
  elif intrinsic "ARGV" streq do
    get_argv_asm return
  elif intrinsic "DIVMOD" streq do
    get_divmod_asm return
  elif intrinsic "DROP" streq do
    get_drop_asm return
  elif intrinsic "DUP" streq do
    get_dup_asm return
  elif intrinsic "ENVP" streq do
    get_envp_asm return
  elif intrinsic "EQ" streq do
    get_eq_asm return
  elif intrinsic "GE" streq do
    get_ge_asm return
  elif intrinsic "GT" streq do
    get_gt_asm return
  elif intrinsic "LE" streq do
    get_le_asm return
  elif intrinsic "LT" streq do
    get_lt_asm return
  elif intrinsic "LOAD_" str.startswith do
    intrinsic get_load_asm
  elif intrinsic "MINUS" streq do
    get_minus_asm return
  elif intrinsic "MUL" streq do
    get_mul_asm return
  elif intrinsic "NE" streq do
    get_ne_asm return
  elif intrinsic "NTH" streq do
    get_nth_asm return
  elif intrinsic "OR" streq do
    get_or_asm return
  elif intrinsic "OVER" streq do
    get_over_asm return
  elif intrinsic "PLUS" streq do
    get_plus_asm return
  elif intrinsic "PRINT" streq do
    get_print_asm return
  elif intrinsic "ROT" streq do
    get_rot_asm return
  elif intrinsic "SHL" streq do
    get_shl_asm return
  elif intrinsic "SHR" streq do
    get_shr_asm return
  elif intrinsic "STORE_" str.startswith do
    intrinsic get_store_asm
  elif intrinsic "SWAP" streq do
    get_swap_asm return
  elif intrinsic "SYSCALL" str.startswith do
    intrinsic get_syscall_asm return
  else
    "Generating assembly for intrinsic '" intrinsic str.cat
    "' is not implemented\n" str.cat
    "" swap NotImplementedError
  endif
end

// Get Assembly comment for Op
// Params: Pointer to Op (PTR)
// Return: Comment string (STR)
function get_op_comment_asm ptr -> str :
  dup   Op.get_type OpType.str
  over  Op.get_token Token.get_value
  take
    token_value
    op_type_str
    op
  in
  // Comment format as Python3 f-string:
  // f";; [{function_name}] {op_type_str} | File: {file}, Row: {row}, Col: {col}\n"
  ";; ["
  op Op.get_function Function.get_name  str.cat
  "] "                                  str.cat

  if op_type_str "FUNCTION_CALL" streq do
    "Call "                             str.cat
    token_value                         str.cat
  elif op_type_str "INTRINSIC" streq do
    op_type_str                         str.cat
    " "                                 str.cat
    token_value                         str.cat
  else
    op_type_str                         str.cat
  endif

  // Add Op.token Location information
  " | File: "                           str.cat
  op Op.get_token Token.get_location
  take token_loc in

  // Add file, row and column information
  token_loc Location.get_file           str.cat
  ", Row: "                             str.cat
  token_loc Location.get_row itoa       str.cat
  ", Column: "                          str.cat
  token_loc Location.get_column itoa    str.cat
  "\n"                                  str.cat
end

// Assign a value to Variable
// Params: Op, Program
// Return: Assembly
function get_assign_bind_asm ptr ptr -> str :
  dup Op.get_id
  take op_id op program in

  // memory_name = program[op.id - 1].token.value
  op_id 1 - program list.nth ptr.load
  Op.get_token Token.get_value

  // bound_memory = f"{op.func.name}_{memory_name}"
  op Op.get_function Function.get_name
  "_" str.cat swap str.cat
  take bound_memory in

  // Generate assembly
  "  pop rax  ; Old value\n"
  "  pop rbx  ; New value\n"  str.cat
  "  mov ["                   str.cat
  bound_memory                str.cat
  "], rbx\n"                  str.cat
end

// BREAK is an unconditional jump to operand after current loop's DONE
// Params: Op, Program
// Return: Assembly
function get_break_asm ptr ptr -> str :
  dup Op.get_function Function.get_name
  take function_name op program in

  program op get_parent_while
  program swap get_done_op_for_while
  Op.get_id
  take parent_done.id in

  "  jmp "
  function_name       str.cat
  "_DONE"             str.cat
  parent_done.id itoa str.cat
end

// CONTINUE is an unconditional jump to current loop's WHILE
// Params: Op, Program
// Return: Assembly
function get_continue_asm ptr ptr -> str :
  dup Op.get_function Function.get_name
  take function_name op program in

  program op get_parent_while
  Op.get_id
  take parent_while.id in

  "  jmp "
  function_name         str.cat
  "_WHILE"              str.cat
  parent_while.id itoa  str.cat
end

// Get the parent IF, ELIF or WHILE for the current DO operand
function get_parent_op_type_do ptr ptr -> int :
  dup Op.get_id 1 - // index = op.id - 1
  0
  take
    parent_count
    index
    do_op
    program
  in

  // for index in range(op.id - 1, -1, -1):
  while index -1 > do

    // Get the current Op's OpType
    index program list.nth ptr.load
    dup Op.get_type
    take op_type op in

    if
      op_type OpType.IF     ==
      op_type OpType.ELIF   == ||
      op_type OpType.WHILE  == ||
    do
      if parent_count 0 == do
        op_type return
      endif
      parent_count 1 - parent_count = // parent_count--
      index 1 - index = // index--
      continue
    endif

    if
      op_type OpType.DONE   ==
      op_type OpType.ENDIF  ==
      ||
    do
      parent_count 1 + parent_count = // parent_count++
    endif
    index 1 - index = // index--
  done
  do_op Op.get_token
  "DO operand without parent IF, ELIF or WHILE\n"
  "AMBIGUOUS_DO" CompilerErrorWithToken NULL
end

// DO is conditional jump to operand after ELIF, ELSE, END or ENDIF
// Params: Op, Program
// Return: Assembly
function get_do_asm ptr ptr -> str :
  over over get_parent_op_type_do
  over Op.get_id 1 + // index = op.id + 1
  0
  take
    parent_op_count
    index
    parent_op_type
    op
    program
  in

  while index program list.len < do
    // Get the current operand's OpType
    index program list.nth ptr.load Op.get_type
    take op_type in

    // Keep count on the nested IFs or WHILEs depending on the parent Op
    if
      // Nested IF block
      parent_op_type  OpType.IF     ==
      parent_op_type  OpType.ELIF   ==
      ||
      op_type         OpType.IF     ==
      &&

      // Nested WHILE block
      parent_op_type  OpType.WHILE  ==
      op_type         OpType.WHILE  ==
      &&

      || // Found nested IF block or WHILE block
    do
      parent_op_count 1 + parent_op_count =
      index 1 + index =
      continue
    endif

    // Generate assembly if we find the corresponding ELIF, ELSE, ENDIF or DONE
    if
      // Found the next possible jump location when the parent OpType is IF
      op_type         OpType.ELIF   ==
      op_type         OpType.ELSE   ==  ||
      op_type         OpType.ENDIF  ==  ||
      parent_op_type  OpType.IF     ==  &&

      // Found the next possible jump location when the parent OpType is ELIF
      op_type         OpType.ELIF   ==
      op_type         OpType.ELSE   ==  ||
      op_type         OpType.ENDIF  ==  ||
      parent_op_type  OpType.ELIF   ==  &&
      ||  // Logical OR with parent IF checks

      // Found the next possible jump location when the parent OpType is WHILE
      parent_op_type  OpType.WHILE  ==
      op_type         OpType.DONE   ==  &&
      ||  // Logical OR with parent IF and ELIF checks

      // The current Op is not inside a nested block
      parent_op_count 0 ==

      // Try if an Op was found which matches any of the earlier checks
      // and also is not found from within a nested block
      &&
    do
      // jump_destination = f"{op.func.name}_{program[index].type}_{index}"
      op Op.get_function Function.get_name
      "_"                                                     str.cat
      index program list.nth ptr.load Op.get_type OpType.str  str.cat
      index itoa                                              str.cat
      generate_do_asm return
    endif

    // Decrement counter when passing another block's ENDIF / DONE
    if
      parent_op_type  OpType.IF     ==
      parent_op_type  OpType.ELIF   == ||
      op_type         OpType.ENDIF  == &&

      parent_op_type  OpType.WHILE  ==
      op_type         OpType.DONE   == &&
      ||
    do
      parent_op_count 1 - parent_op_count =
      index 1 + index =
      continue
    endif
    index 1 + index = // index++
  done
  "The current block is missing the corresponding closing keyword\n"
  "UNCLOSED_BLOCK" CompilerError ""
end

// DO pops an item from the stack and jumps to jump_destination if it is zero
// Params: jump_destination (STR)
// Return: Assembly
function generate_do_asm str -> str :
  "  pop rax\n"
  "  test rax, rax\n" str.cat
  "  jz "             str.cat
  swap                str.cat
  "\n"                str.cat
end

// DONE is an unconditional jump to current loop's WHILE
// Params: Op, Program
// Return: Assembly
function get_done_asm ptr ptr -> str :
  take op program in

  // Get the parent WHILE Op
  program op get_parent_while
  take parent_while in

  // Generate assembly
  op Op.get_function Function.get_name
  op Op.get_id itoa
  parent_while Op.get_id itoa
  take
    parent_while.id
    op.id
    function_name
  in

  "  jmp "
  function_name     str.cat
  "_WHILE"          str.cat
  parent_while.id   str.cat
  "\n"              str.cat
  function_name     str.cat
  "_DONE"           str.cat
  op.id             str.cat
  ":\n"             str.cat
end

// ELIF is an unconditional jump to ENDIF and a keyword for DO to jump to
// Params: Op, Program
// Return: Assembly
function get_elif_asm ptr ptr -> str :
  take op program in

  // Get the related ENDIF Op
  program op get_related_endif
  take related_endif in

  // Generate assembly
  op Op.get_function Function.get_name
  op Op.get_id itoa
  related_endif Op.get_id itoa
  take
    related_endif.id
    op.id
    function_name
  in

  "  jmp "
  function_name     str.cat
  "_ENDIF"          str.cat
  related_endif.id  str.cat
  "\n"              str.cat
  function_name     str.cat
  "_ELIF"           str.cat
  op.id             str.cat
  ":\n"             str.cat
end

// ELSE is an unconditional jump to ENDIF and a keyword for DO to jump to
// Params: Op, Program
// Return: Assembly
function get_else_asm ptr ptr -> str :
  take op program in

  // Get the related ENDIF Op
  program op get_related_endif
  take related_endif in

  // Generate assembly
  op Op.get_function Function.get_name
  op Op.get_id itoa
  related_endif Op.get_id itoa
  take
    related_endif.id
    op.id
    function_name
  in

  "  jmp "
  function_name     str.cat
  "_ENDIF"          str.cat
  related_endif.id  str.cat
  "\n"              str.cat
  function_name     str.cat
  "_ELSE"           str.cat
  op.id             str.cat
  ":\n"             str.cat
end

// ENDIF is just a keyword for DO, ELIF or ELSE to jump to
// Params: Op
// Return: Assembly
function get_endif_asm ptr -> str :
  take op in
  op Op.get_function Function.get_name
  "_ENDIF"          str.cat
  op Op.get_id itoa str.cat
  ":\n"             str.cat
end

// Generate assembly for calling a function
// Params: Function's name
// Return: Assembly
function get_function_call_asm str -> str :
  "  call "
  swap get_valid_label_for_nasm str.cat
  "\n" str.cat
end

// Generate Assembly for OpType.PEEK
// Params: None
// Return: Assembly
function get_peek_asm -> str :
  // Save current stack pointer to r15
  "  mov r15, rsp\n"
end

// Generate Assembly for OpType.PEEK_BIND
// Params: Op
// Return: Assembly
function get_peek_bind_asm ptr -> str :
  get_bound_memory
  "  mov rax, [r15]\n"
  "  mov ["         str.cat
  swap              str.cat
  "], rax\n"        str.cat
  "  add r15, 8\n"  str.cat
end

// Generate Assembly for OpType.POP_BIND
// Params: Op
// Return: Assembly
function get_pop_bind_asm ptr -> str :
  get_bound_memory
  "  pop qword ["
  swap  str.cat
  "]\n" str.cat
end

// Generate Assembly for OpType.POP_BIND
// Params: Op
// Return: Assembly
function get_push_bind_asm ptr -> str :
  get_bound_memory
  "  push qword ["
  swap  str.cat
  "]\n" str.cat
end

// Generate Assembly for OpType.PUSH_BOOL
// Params: Op.token.value
// Return: Assembly
function get_push_bool_asm str -> str :
  if dup "TRUE" streq
  do    drop  "  mov rax, 1\n"
  else  drop  "  mov rax, 0\n"
  endif       "  push rax\n" str.cat
end

// Generate Assembly for OpType.PUSH_CHAR
// Params: Op.token.value[1] ('a' => a)
// Return: Assembly
function get_push_char_asm char -> str :
  int itoa
  "  mov rax, " swap  str.cat
  "\n  push rax\n"    str.cat
end

// Generate Assembly for OpType.PUSH_INT
// Params: Op.token.value
// Return: Assembly
function get_push_int_asm str -> str :
  "  mov rax, " swap  str.cat
  "\n  push rax\n"    str.cat
end

// Generate Assembly for OpType.PUSH_PTR
// Params: Op.token.value
// Return: Assembly
function get_push_ptr_asm str -> str :
  "  mov rax, " swap  str.cat
  "\n  push rax\n"    str.cat
end

// Generate Assembly for OpType.PUSH_STR
// Params: Op
// Return: Assembly
function get_push_str_asm ptr -> str :
  // Initialize variables
  dup   Op.get_id itoa
  swap  Op.get_function Function.get_name
  take
    function_name
    op_id
  in

  "  mov rsi, "
  function_name             str.cat
  "_s"                      str.cat
  op_id                     str.cat
  " ; Pointer to string\n"  str.cat
  "  push rsi\n"            str.cat
end

// Generate Assembly for OpType.RETURN
// Params: Function.name
// Return: Assembly
function get_return_asm str -> str :
  if dup str.copy str.upper "MAIN" streq do
    "0"   get_push_int_asm
    swap  get_function_end_asm str.cat
    return
  endif
  get_function_end_asm
end

// Generate Assembly for OpType.WHILE
// Params: Op
// Return: Assembly
function get_while_asm ptr -> str :
  // Initialize variables
  dup   Op.get_id itoa
  swap  Op.get_function Function.get_name
  take
    function_name
    op_id
  in

  function_name
  "_WHILE"  str.cat
  op_id     str.cat
  ":\n"     str.cat
end

// Return the assembly code for arithmetic Intrinsics (PLUS, MINUS, MUL)
// Params: operand
// Return: Assembly
function get_arithmetic_asm str -> str :
  take operand in
  "  pop rbx\n"
  "  pop rax\n  " str.cat
  operand         str.cat
  " rax, rbx\n"   str.cat
  "  push rax\n"  str.cat
end

// Generate assembly code for different comparison Intrinsics, like EQ and GE.
// Only the cmov operand changes with different comparison intrinsics.
// Params: cmov_operand
// Return: Assembly
function get_comparison_asm str -> str :
  "  pop rax\n"
  "  pop rbx\n"         str.cat
  "  mov rcx, 0\n"      str.cat
  "  mov rdx, 1\n"      str.cat
  "  cmp rbx, rax\n  "  str.cat
  swap                  str.cat // cmov_operand
  " rcx, rdx\n"         str.cat
  "  push rcx\n"        str.cat
end

// AND performs bitwise-AND operation to two integers
// Params: None
// Return: Assembly
function get_and_asm -> str :
  "  pop rax\n"
  "  pop rbx\n"       str.cat
  "  and rbx, rax\n"  str.cat
  "  push rbx\n"      str.cat
end

// ARGC pushes the argument count to the stack
// Params: None
// Return: Assembly
function get_argc_asm -> str :
  "  mov rax, [args_ptr]\n"
  "  mov rax, [rax]\n"  str.cat
  "  push rax\n"        str.cat
end

// ARGV pushes the pointer to argument array to the stack
// Params: None
// Return: Assembly
function get_argv_asm -> str :
  "  mov rax, [args_ptr]\n"
  "  add rax, 8\n"  str.cat
  "  push rax\n"    str.cat
end

// DIVMOD pops two integers from the stack and pushes their remainder and quotient
// Params: None
// Return: Assembly
function get_divmod_asm -> str :
  "  xor edx, edx ; Do not use floating point arithmetic\n"
  "  pop rbx\n"               str.cat
  "  pop rax\n"               str.cat
  "  div rbx\n"               str.cat
  "  push rdx ; Remainder\n"  str.cat
  "  push rax ; Quotient\n"   str.cat
end

// DROP removes one item from the stack
// Params: None
// Return: Assembly
function get_drop_asm -> str :
  "  add rsp, 8\n"
end

// DUP duplicates the top element in the stack
// Params: None
// Return: Assembly
function get_dup_asm -> str :
  "  pop rax\n"
  "  push rax\n" str.cat
  "  push rax\n" str.cat
end

// ENVP pushes the environment pointer to the stack
// Params: None
// Return: Assembly
function get_envp_asm -> str :
  "  mov rax, [args_ptr]\n"
  "  add rax, 24\n" str.cat
  "  push rax\n"    str.cat
end

// EQ takes two elements from the stack and checks if they are equal.
// Then it pushes the boolean value of the comparison.
// Params: None
// Return: Assembly
function get_eq_asm -> str :
  "cmove" get_comparison_asm
end

// GE takes two items from the stack and checks if the second item >= the other.
// Then it pushes the boolean value of the comparison.
// Params: None
// Return: Assembly
function get_ge_asm -> str :
  "cmovge" get_comparison_asm
end

// GT takes two items from the stack and checks if the second item > the other.
// Then it pushes the boolean value of the comparison.
// Params: None
// Return: Assembly
function get_gt_asm -> str :
  "cmovg" get_comparison_asm
end

// LE takes two items from the stack and checks if the second item <= the other.
// Then it pushes the boolean value of the comparison.
// Params: None
// Return: Assembly
function get_le_asm -> str :
  "cmovle" get_comparison_asm
end

// LT takes two items from the stack and checks if the second item < the other.
// Then it pushes the boolean value of the comparison.
// Params: None
// Return: Assembly
function get_lt_asm -> str :
  "cmovl" get_comparison_asm
end

// Params: load_variant
// Return: Assembly
function get_load_asm str -> str :
  str.copy str.upper
  take load_variant in

  // Get the correct size register for the load_variant
  if    load_variant "LOAD_BYTE"  streq do "bl"
  elif  load_variant "LOAD_WORD"  streq do "bx"
  elif  load_variant "LOAD_DWORD" streq do "ebx"
  elif  load_variant "LOAD_QWORD" streq do "rbx"
  else
    "'" load_variant                  str.cat
    "' is not a valid LOAD Intrinsic" str.cat
    "VALUE_ERROR" CompilerError ""
  endif
  take register in

  // Generate assembly
  "  pop rax\n"
  "  xor rbx, rbx\n"  str.cat
  "  mov "            str.cat
  register            str.cat
  ", [rax]\n"         str.cat
  "  push rbx\n"      str.cat
end

// Pop two integers from the stack and decrement the second value from the top one
function get_minus_asm -> str :
  "sub" get_arithmetic_asm
end

// Pop two integers from the stack and push the product of the two values
// Params: None
// Return: Assembly
function get_mul_asm -> str :
  "  pop rax\n"
  "  pop rbx\n"             str.cat
  "  mul rbx\n"             str.cat
  "  push rax  ; Product\n" str.cat
end

// NE takes two items from the stack and checks if they are not equal.
// Then it pushes the boolean value of the comparison.
// Params: None
// Return: Assembly
function get_ne_asm -> str :
  "cmovne" get_comparison_asm
end

// Copies Nth element from the stack to the top of the stack.
// Note that the Nth is counted without the popped integer.
// Example: 30 20 10 3 NTH print  // Output: 30
// => 30 is 3rd element without the popped 3
function get_nth_asm -> str :
  "  pop rax\n"
  "  sub rax, 1\n"                                      str.cat
  "  mov rbx, 8\n"                                      str.cat
  "  mul rbx\n"                                         str.cat
  "  add rsp, rax ; Stack pointer to the Nth element\n" str.cat
  "  pop rbx      ; Get Nth element to rax\n"           str.cat
  "  add rax, 8\n"                                      str.cat
  "  sub rsp, rax ; Return stack pointer\n"             str.cat
  "  push rbx\n"                                        str.cat
end

// OR performs bitwise-OR operation to two integers
// Params: None
// Return: Assembly
function get_or_asm -> str :
  "  pop rax\n"
  "  pop rbx\n"     str.cat
  "  or rbx, rax\n" str.cat
  "  push rbx\n"    str.cat
end

// OVER Intrinsic pushes a copy of the second element of the stack
// Params: None
// Return: Assembly
function get_over_asm -> str :
  "  pop rax\n"
  "  pop rbx\n"  str.cat
  "  push rbx\n" str.cat
  "  push rax\n" str.cat
  "  push rbx\n" str.cat
end

// Pop two integers from the stack and push the sum of the two values
// Params: None
// Return: Assembly
function get_plus_asm -> str :
  "add" get_arithmetic_asm
end

// Pop an integer from the stack and print the value of it to the stdout
// Params: None
// Return: Assembly
function get_print_asm -> str :
  "  pop rdi\n"
  "  call print\n"    str.cat
end

// Rotate the top three elements of the stack so that the third becomes first
// Params: None
// Return: Assembly
function get_rot_asm -> str :
  "  pop rax\n"
  "  pop rbx\n"   str.cat
  "  pop rcx\n"   str.cat
  "  push rbx\n"  str.cat
  "  push rax\n"  str.cat
  "  push rcx\n"  str.cat
end

// SHL Intrinsic shifts the bits of the second argument to the left
// as many times as indicated by the first.
// Params: None
// Return: Assembly
function get_shl_asm -> str :
  "  pop rcx\n"
  "  pop rbx\n"     str.cat
  "  shl rbx, cl\n" str.cat
  "  push rbx\n"    str.cat
end

// SHR Intrinsic shifts the bits of the second argument to the right
// as many times as indicated by the first.
// Params: None
// Return: Assembly
function get_shr_asm -> str :
  "  pop rcx\n"
  "  pop rbx\n"     str.cat
  "  shr rbx, cl\n" str.cat
  "  push rbx\n"    str.cat
end

// Params: store_variant
// Return: Assembly
function get_store_asm str -> str :
  str.copy str.upper
  take store_variant in

  // Get the correct size register for the store_variant
  if    store_variant "STORE_BYTE"  streq do "bl"
  elif  store_variant "STORE_WORD"  streq do "bx"
  elif  store_variant "STORE_DWORD" streq do "ebx"
  elif  store_variant "STORE_QWORD" streq do "rbx"
  else
    "'" store_variant                  str.cat
    "' is not a valid STORE Intrinsic" str.cat
    "VALUE_ERROR" CompilerError ""
  endif
  take register in

  // Generate assembly
  "  pop rax\n"
  "  pop rbx\n"   str.cat
  "  mov [rax], " str.cat
  register        str.cat
  "\n"            str.cat
end

// Swap the top two items in the stack
// Params: None
// Return: Assembly
function get_swap_asm -> str :
  "  pop rax\n"
  "  pop rbx\n"   str.cat
  "  push rax\n"  str.cat
  "  push rbx\n"  str.cat
end

// SYSCALL intrinsic variants call a Linux syscall.
// Different variants are named SYSCALL0 - SYSCALL6 by the amount of arguments.
// Params: Token.value.upper()
// Return: Assembly
function get_syscall_asm str -> str :

  // Get the Syscall variant's number
  7 str.char_at '0' -

  // Get argument registers used for syscalls (List[str])
  get_syscall_argument_registers
  0
  take
    index
    argument_registers
    syscall_args_count
  in

  // Generate assembly code
  "  pop rax ; syscall\n"
  while index syscall_args_count < do
    "  pop "                                    str.cat
    index argument_registers list.nth str.load  str.cat
    " ; "                                       str.cat

    index 1 + index = // index++
    index itoa                                  str.cat
    ". arg\n"                                   str.cat
  done

  "  syscall\n"                                 str.cat
  "  push rax ; return code\n"                  str.cat
end

function get_syscall_argument_registers -> ptr :
  list.init

  // Add Syscall argument registers in the correct order
  "rdi" ptr swap list.append
  "rsi" ptr swap list.append
  "rdx" ptr swap list.append
  "r10" ptr swap list.append
  "r8"  ptr swap list.append
  "r9"  ptr swap list.append
end

function get_exit_assembly -> str :
  ";; -- exit syscall\n"
  "  mov rax, sys_exit\n" str.cat
  "  pop rdi\n"           str.cat
  "  syscall\n\n"         str.cat
end

// Generate assembly code for NASM
// Params: sub_programs (List[Program]), List[Memory]
// Return: Intel x86_64 Assembly for NASM (STR)
function generate_assembly_code ptr ptr -> str :
  over initialize_asm
  over list.len
  "section .data\n" str.copy
  0
  take
    index
    data_section_asm
    sub_programs.len
    assembly_code
    sub_programs
    memories
  in

  // Iterate over each Program in sub_programs
  while index sub_programs.len < do

    // Get the current Program
    sub_programs list.first
    index ptr.size * ptr+ ptr.load
    take program in

    // Get assembly code for the current Program
    program get_programs_assembly_code

    // Concatenate the Program's assembly to assembly_code
    assembly_code swap str.cat
    assembly_code =

    // Add strings from the program to the .data section
    program get_string_variables_for_data_section
    data_section_asm swap str.cat
    data_section_asm =

    index 1 + index = // index++
  done
  assembly_code data_section_asm str.cat
end

// Get Assembly code to be added to .data section from Program's string variables
function get_string_variables_for_data_section ptr -> str :
  "" str.copy
  0
  take
    index
    assembly_code
    program
  in
  while index program list.len < do
    // Get current Op
    index program list.nth ptr.load
    take op in

    // Add only strings to the assembly
    if op Op.get_type OpType.PUSH_STR != do
      index 1 + index =
      continue
    endif

    op    Op.get_id itoa
    op    Op.get_function Function.get_name
    op    Op.get_token
    dup   Token.get_value format_escape_sequences_for_nasm
    swap  Token.get_location
    take
      token_location
      string
      function_name
      op_id
    in

    "  "
    function_name str.cat
    "_s"          str.cat
    op_id         str.cat
    " db "        str.cat
    string        str.cat
    ",0\n"        str.cat

    assembly_code swap str.cat
    assembly_code =
    index 1 + index =
  done
  assembly_code
end

function format_escape_sequences_for_nasm str -> str :
  34 char char.to_string
  92 char char.to_string
  take
    backslash
    double_quote
    string
  in

  // Save escape sequences to variables
  backslash "t" str.cat
  backslash "n" str.cat
  backslash "r" str.cat
  backslash "e" str.cat

  take
    Escape
    CR
    LF
    Tab
  in

  // Replace escape sequences with valid assembly for NASM
  double_quote ",9," str.cat double_quote str.cat
  Tab string str.replace string =

  double_quote ",10," str.cat double_quote str.cat
  LF string str.replace string =

  double_quote ",13," str.cat double_quote str.cat
  CR string str.replace string =

  double_quote ",27," str.cat double_quote str.cat
  Escape string str.replace string =

  string
end

// Return the beginning of the assembly code of each Program
// Params: Function's name
// Return: Assembly code
function get_function_start_asm str -> str :
  take function_name in

  // MAIN Function differs from the others
  if function_name str.copy str.upper "MAIN" streq do
    "global _start\n"
    "_start:\n"                                                           str.cat
    "  mov [args_ptr], rsp   ; Pointer to argc\n"                         str.cat
    return
  endif

  function_name get_valid_label_for_nasm
  ":\n;; ["                                                               str.cat
  function_name                                                           str.cat
  "] Save the return address to return_stack\n"                           str.cat
  "  mov rax, return_stack\n"                                             str.cat
  "  add rax, [return_stack_index]\n"                                     str.cat
  "  pop qword [rax]\n"                                                   str.cat
  "  add qword [return_stack_index], 8  ; Increment return_stack_index\n" str.cat
end

// Return the end of the assembly code of each Program
// Params: Function's name
// Return: Assembly code
function get_function_end_asm str -> str :
  take function_name in

  // MAIN Function differs from the others
  if function_name str.copy str.upper "MAIN" streq do
    get_exit_assembly return
  endif

  ";; ["
  function_name                                                           str.cat
  "] Return to the address found in return_stack\n"                       str.cat
  "  sub qword [return_stack_index], 8  ; Decrement return_stack_index\n" str.cat
  "  mov rax, return_stack\n"                                             str.cat
  "  add rax, [return_stack_index]\n"                                     str.cat
  "  push qword [rax]\n"                                                  str.cat
  "  ret\n\n"                                                             str.cat
end

function get_programs_assembly_code ptr -> str :
  dup list.len
  "" str.copy
  0
  take
    index
    assembly_code
    program.len
    program
  in

  // Generate assembly for each Op in Program
  while index program.len < do
    // Get the current Op
    program list.first
    index ptr.size * ptr+ ptr.load
    take op in

    // Generate comment for Op
    assembly_code op get_op_comment_asm str.cat

    // Concatenate Op's Assembly to op_asm
    program op get_op_asm str.cat
    assembly_code =
    index 1 + index =
  done

  // Get the Function's name to be added to the assembly code
  // Exception: MAIN Function should be named '_start'
  op Op.get_function Function.get_name
  take function_name in

  // Prepend the Function's beginning code and prepend the ending code
  function_name get_function_start_asm
  assembly_code str.cat
  function_name get_function_end_asm str.cat
end

// Returns the current IF block's ENDIF Op
// Params: Op, Program
// Return: Op
function get_related_endif ptr ptr -> ptr :
  dup Op.get_id 1 + // index = op.id + 1
  0 // if_count => Keep count of the nested IF blocks
  take
    if_count
    index
    op
    program
  in

  while index program list.len < do
    index program list.nth ptr.load
    dup Op.get_type
    take current_op_type current_op in

    // Return the found ENDIF if it's not inside nested IF block
    if current_op_type OpType.ENDIF == do
      if if_count 0 == do
        current_op return
      endif
      if_count 1 - if_count = // if_count--
    endif

    // Increment if_count when nested blocks are found
    if current_op_type OpType.IF == do
      if_count 1 + if_count = // if_count++
    endif

    index 1 + index = // index++
  done

  // Report error when corresponding ENDIF was not found
  "Corresponding ENDIF keyword was not found.\n"
  op Op.get_token Token.get_value str.copy str.upper
  "AMBIGUOUS_" swap str.cat CompilerError NULLPTR
end

// Returns the current WHILE block's DONE Op
// Params: Op, Program
// Return: Op
function get_parent_while ptr ptr -> ptr :
  dup Op.get_id 1 - // index = op.id - 1
  0 // done_count => Keep count of the nested WHILE blocks
  take
    done_count
    index
    op
    program
  in

  while index -1 > do
    index program list.nth ptr.load
    dup Op.get_type
    take current_op_type current_op in

    // Return the found ENDIF if it's not inside nested IF block
    if current_op_type OpType.WHILE == do
      if done_count 0 == do
        current_op return
      endif
      done_count 1 - done_count = // done_count--
    endif

    // Increment done_count when nested blocks are found
    if current_op_type OpType.DONE == do
      done_count 1 + done_count = // done_count++
    endif

    index 1 - index = // index--
  done

  // Report error when parent WHILE was not found
  "Parent WHILE keyword was not found.\n"
  op Op.get_token Token.get_value str.copy str.upper
  "AMBIGUOUS_" swap str.cat
  CompilerError NULLPTR
end

// Returns the END Operand for the current WHILE block
// Params: Op, Program
// Return: Op
function get_done_op_for_while ptr ptr -> ptr :
  dup Op.get_id
  0
  take
    while_count
    index
    op
    program
  in

  // Iterate over each Op of the Program starting from the parameter Op
  while index program list.len < do

    // Get the current Operands OpType
    index program list.nth ptr.load
    dup Op.get_type
    take current_op_type current_op in

    // Return the found DONE if it's not inside nested WHILE block
    if current_op_type OpType.DONE == do
      while_count 1 - while_count = // while_count--
      if while_count 0 == do
        current_op return
      endif
    endif

    // Increment while_count when nested WHILE blocks are found
    if current_op_type OpType.WHILE == do
      while_count 1 + while_count = // while_count++
    endif

    index 1 + index = // index++
  done

  // Report error when END Keyword was not found for the WHILE block
  op Op.get_token
  "END keyword was not found for the current WHILE loop.\n"
  op Op.get_token Token.get_value str.copy str.upper
  "AMBIGUOUS_" swap str.cat CompilerErrorWithToken NULLPTR
end

// Get memory name for assembly used by a bound memory
// Params: Op
// Return: bound_memory
function get_bound_memory ptr -> str :
  // bound_memory = f"{op.func.name}_{memory_name}"
  take op in
  op Op.get_token     Token.get_value
  op Op.get_function  Function.get_name
  "_" str.cat swap str.cat
end

// Generate valid NASM label for Function
// Params: function_name
// Return: label
function get_valid_label_for_nasm str -> str :
  dup base64.encode
  take b64_function_name function_name in
  b64_function_name dup str.len 2 - str+
  NULL char swap ptr char.store

  // Append the sum of the last characters of the function
  // to prevent redefinitions of functions with similar names
  function_name dup str.len 1 - str.char_at
  function_name dup str.len 2 - str.char_at +
  b64_function_name swap itoa str.cat
end
