// lex.torth - Lexing functions that parses Tokens from code files
include "std"
include "compiler/defs"
include "compiler/utils"
include "compiler/class/Function"
include "compiler/class/Op"
include "compiler/class/Token"

// Transfer comparison and calculations related symbols to their text counterparts
// Params: Token match from code (STR)
// Return: Value for Token (STR)
function get_token_value str -> str :
  str.copy
  take token_match in
  if   token_match "==" streq do
    "EQ" return
  elif token_match ">=" streq do
    "GE" return
  elif token_match ">"  streq do
    "GT" return
  elif token_match "<=" streq do
    "LE" return
  elif token_match "<"  streq do
    "LT" return
  elif token_match "-"  streq do
    "MINUS" return
  elif token_match "*"  streq do
    "MUL" return
  elif token_match "!=" streq do
    "NE" return
  elif token_match "+"  streq do
    "PLUS" return
  endif
  token_match
end

const single_quote 39 end
function get_token_type str -> int :
  take token_value in
  // TODO: TokenType.KEYWORD
  // Boolean => True
  if
    token_value str.copy str.upper
    dup   "TRUE"  streq
    swap  "FALSE" streq
    ||
  do
    TokenType.BOOL return
  // Character => 'a'
  elif
    token_value str.len 3 ==
    token_value ptr char.load single_quote ==
    token_value 2 str.char_at single_quote ==
    && &&
  do
    TokenType.CHAR return
  // Integer => 1337
  elif
    token_value str.is_numeric
  do
    TokenType.INT return
  // Hexadecimal => 0x1337
  elif
    token_value ptr char.load '0' ==
    token_value 1 str.char_at 'x' ==
    &&
  do
    TokenType.INT return
  // String => "This is string\n"
  elif
    token_value ptr char.load                '"' ==
    token_value dup str.len 1 - str.char_at  '"' ==
    &&
  do
  TokenType.STR return
  // uint8 => u69
  elif
    token_value ptr char.load 'u' ==
    token_value 1 str.char_at char.is_numeric
    &&
  do
    TokenType.UINT8 return
  endif
  TokenType.WORD
end

function get_token_from_match str -> ptr :
  get_token_value dup
  get_token_type
  get_dummy_location
  swap rot Token.init
end

// Dummy memories for testing purposes
memory dummy_token_list ptr.size end
function get_tokens_function ptr -> ptr :
  drop "[TODO] Parsing Token's function is not implemented yet.\n" eputs
  dummy_token_list get_dummy_signature "test" Function.init
end

function get_op_type ptr -> int :
  Token.get_type
  take token_type in
  if token_type TokenType.BOOL == do
    OpType.PUSH_BOOL return
  elif token_type TokenType.CHAR == do
    OpType.PUSH_CHAR return
  elif token_type TokenType.INT == do
    OpType.PUSH_INT return
  elif token_type TokenType.STR == do
    OpType.PUSH_STR return
  elif token_type TokenType.UINT8 == do
    OpType.PUSH_UINT8 return
  endif
  OpType.INTRINSIC
end

// Generate Op from Token
// Params: token (PTR), id (INT)
// Return: op (PTR)
function get_op_from_token ptr int -> ptr :
  take token id in
  // Op(id=id, type=op_type, token=token, function=function)
  token get_tokens_function // function
  token                     // token
  token get_op_type         // op_type
  id                        // id
  Op.init
end
