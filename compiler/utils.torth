// utils.torth - Utility functions for Torth compiler
include "std"
include "argparser"
include "typing"
include "compiler/defs"
include "compiler/class/Location"
include "compiler/class/Signature"
include "compiler/class/Token"
include "compiler/class/TypeNode"

// Parse command line arguments with Argparser
// Params: None
// Return: Argparser
function parse_command_line_arguments -> ptr :
  "Torth compiler" Argparser.init
  take parser in
  False "FILE" "Output file" "--out"                parser Argparser.add_argument
  False "FILE" "Run program after compilation" "-r" parser Argparser.add_argument
  True  "FILE" "Input file" "code_file"             parser Argparser.add_argument
  parser Argparser.parse_args
  parser
end

// Run a program
// Params: file_name
// Return: None
function run_program str :
  "EXEC" exec_forked
end

// Execute a certain kind of command
function exec_forked str str :
  take cmd file in
  SYS_fork SYSCALL0

  // Child: Compile the assembly code with NASM
  if dup 0 == do
    file cmd exec_command
  // Parent: Wait for child to exit
  elif dup -1 != do
    NULL NULL NULL -1 SYS_wait4 SYSCALL4 drop
  // Report error if forking the process failed
  else
    "[ERROR] Could not fork the process\n"
    "FORK_ERROR" CompilerError
  endif drop
end

// Execute another function with an alias string
// NASM => compile_with_nasm
function exec_command str str :
  take cmd file in
  if cmd "NASM" streq do
    file compile_with_nasm
  elif cmd "LD" streq do
    file link_with_ld
  elif cmd "EXEC" streq do
    file execute_program
  elif cmd "RM" streq do
    file remove_file
  else
    "Unknown command '" eputs
    cmd                 eputs
    "'\n"               eputs
  endif
end

// Run executable
// Params: file
// Return: None
function execute_program str :
  "./" swap str.cat
  str.size malloc
  take argv executable in

  executable argv str.store
  NULLPTR argv executable execve drop
end

function get_token_info ptr -> str :
  take token in
  "\e[95mToken\e[0m: "
  token Token.get_value str.cat
  "\n" str.cat
  token Token.get_location get_location_info str.cat
end

// Remove a file
// Params
//    file_name: str
// Return None
function remove_file str :
  // Allocate memory for the arguments
  List.init
  take argv file_name in

  "rm"        ptr argv List.append
  file_name   ptr argv List.append
  NULLPTR argv List.first "/usr/bin/rm" execve drop
end

function get_location_info ptr -> str :
  take location in
  "\e[95mFile\e[0m: "
  location Location.get_file        str.cat
  "\n\e[95mRow\e[0m: "              str.cat
  location Location.get_row itoa    str.cat
  "\n\e[95mColumn\e[0m: "           str.cat
  location Location.get_column itoa str.cat
  "\n"                              str.cat
end

// Get the output file name from command line arguments
// Params: Argparser
// Return: file_name
function get_output_file_name ptr -> str :
  "--out" swap Argparser.get_argument
  take file_name in

  if file_name ptr int NULL == do
    "a.bin" return
  endif
  file_name
end

// Get Op from Location found in a Program
// Params: Location, Program
// Return: Op
function get_op_from_location ptr ptr -> ptr :
  int // Cast Location pointer to int
  over List.len
  0
  take
    index
    program.len
    location
    program
  in

  while index program.len < do
    index program List.nth ptr.load
    take op in

    // Test if the current Op has the same Location pointer
    op Op.get_token Token.get_location int
    take current_location in
    if location current_location == do
      op return
    endif
    index 1 + index =
  done

  "OP_NOT_FOUND"
  "Operand could not be found from the given location"
  CompilerError NULLPTR
end

// Check if a Constant with a certain name exists
// Params: constant_name, List[Constant]
// Return: bool
function constant_exists str ptr -> bool :
  0
  take
    index
    constant_name
    constants
  in

  // Iterate over constants and check if a Constant with certain name exists
  while index constants List.len < do

    // Get the current Constant
    index constants List.nth ptr.load Constant.get_name
    take current_name in

    // Return True if current Constant's name matches constant_name parameter
    if current_name constant_name streq do
      True return
    endif
    index 1 + index = // index++
  done

  // Return False if the Constant was not found
  False
end

// Check if a Function with a certain name exists
// Params: function_name, List[Functions]
// Return: bool
function function_exists str ptr -> bool :
  // Function does not exist if get_function_by_name returns NULLPTR
  get_function_by_name int
  NULL !=
end

// Get printable representation of TokenType
function TokenType.repr int -> str :
  take token_type in
  if token_type TokenType.ANY == do
    "ANY" return
  elif token_type TokenType.BOOL == do
    "BOOL" return
  elif token_type TokenType.CHAR == do
    "CHAR" return
  elif token_type TokenType.INT == do
    "INT" return
  elif token_type TokenType.PTR == do
    "PTR" return
  elif token_type TokenType.STR == do
    "STR" return
  elif token_type TokenType.UINT8 == do
    "UINT8" return
  endif
  "Unknown TokenType: " eputs
  token_type eputi
  "\n" eputs
  1 exit ""
end

// Two TokenTypes are matching if they are equal
// or if either of them is TokenType.ANY
// Params
//    type1: TokenType
//    type2: TokenType
// Return bool
function matching_token_types int int -> bool :
  take type1 type2 in
  type1 type2 ==
  type1 TokenType.ANY == ||
  type2 TokenType.ANY == ||
end

// Get a Function with certain name from a list of Functions
// Params: function_name, List[Functions]
// Return: Function
function get_function_by_name str ptr -> ptr :
  0
  take
    index
    function_name
    functions
  in

  // Iterate over functions and check if a Function with certain name exists
  while index functions List.len < do

    // Get the current Function
    index functions List.nth ptr.load
    take func in

    // Return True if current Function's name matches function_name parameter
    if func Function.get_name function_name streq do
      func return
    endif
    index 1 + index = // index++
  done

  // Return NULLPTR if the Function was not found
  NULLPTR
end

// Check if a Memory with a certain name exists
// Params: memory_name, List[Memory]
// Return: bool
function memory_exists str ptr -> bool :
  0
  take
    index
    memory_name
    memories
  in

  // Iterate over memories and check if a Memory with certain name exists
  while index memories List.len < do

    // Get the current Memory
    index memories List.nth ptr.load Memory.get_name
    take current_name in

    // Return True if current Memory's name matches memory_name parameter
    if current_name memory_name streq do
      True return
    endif
    index 1 + index = // index++
  done

  // Return False if the Memory was not found
  False
end

// Get Nth command line argument
// Params: index
// Return: *argv[index]
function get_nth_cmd_line_argument int -> str :
  int.size * argv swap ptr+ str.load
end

// Get Constant with certain name from List[Constants]
// Params: name (STR), List[Constant]
// Return: Constant
function get_constant str ptr -> ptr :
  0
  take
    index
    name
    constants
  in

  // Iterate over each Constant
  while index constants List.len < do

    // Get current Constant
    index constants List.nth ptr.load
    take constant in

    // Return current Constant if its name matches the name parameter
    if constant Constant.get_name name streq do
      constant return
    endif
    index 1 + index = // index++
  done
  NULLPTR // Constant was not found
end

// Perform a deep copy of the TypeStack
// Params
//    type_stack: LinkedList[TypeNode]
// Return
//    type_stack_copy: LinkedList[TypeNode]
function TypeStack.copy ptr -> ptr :
  dup Node.get_data
  LinkedList.init
  0
  take
    stack_depth
    type_stack_copy
    node
    type_stack
  in

  // Empty TypeStack
  if type_stack LinkedList.len 0 == do
    type_stack_copy return
  endif

  // Traverse the TypeStack to the first Node
  while node Node.get_next int NULL != do
    node Node.get_next node =
    stack_depth 1 + stack_depth =
  done

  // Fill the copy TypeStack with the contents of the original
  while stack_depth 0 >= do
    // Generate new TypeNode from the original stack
    node Node.get_data
    take type_node in
    type_node TypeNode.get_location
    type_node TypeNode.get_type
    TypeNode.init
    type_stack_copy LinkedList.push

    // Get the next item in the stack
    node Node.get_prev node =
    stack_depth 1 - stack_depth =
  done
  type_stack_copy
end

// Get a List of TokenTypes from TypeStack
// Params
//    type_stack: LinkedList[TypeNode]
// Return
//    token_types: List[TokenType]
function TypeStack.get_types ptr -> ptr :
  dup Node.get_data
  List.init
  0
  take
    stack_depth
    token_types
    node
    type_stack
  in

  // Handle the empty case
  if type_stack LinkedList.len 0 == do
    token_types return
  endif

  // Traverse the TypeStack to the first Node
  while node Node.get_next int NULL != do
    node Node.get_next node =
    stack_depth 1 + stack_depth =
  done

  // Fill List with the TokenTypes inside TypeStack
  while stack_depth 0 >= do
    node Node.get_data
    TypeNode.get_type ptr token_types List.append
    stack_depth 1 - stack_depth =
  done
  token_types
end

// Get a string representation of a TypeStack
// Params
//    type_stack: LinkedList[TypeNode]
// Return
//    stack_repr: str
function TypeStack.repr ptr -> str :
  TypeStack.copy
  "" str.copy
  take stack_repr type_stack in

  // Check for empty LinkedList
  if type_stack LinkedList.is_empty do
    "[EMPTY]\n" str.copy return
  endif

  type_stack LinkedList.pop
  1
  take index node in
  while node int -1 != do
    "[" index
    itoa                                  str.cat
    "] "                                  str.cat
    node TypeNode.get_type TokenType.repr str.cat
    "\n"                                  str.cat
    stack_repr swap                       str.cat
    stack_repr =

    // Pop the next item from TypeStack
    type_stack LinkedList.pop node =
    index 1 + index =
  done
  stack_repr
end
