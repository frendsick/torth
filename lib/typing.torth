// typing.torth - Definitions for non-built in types
include "std"
include "compiler/class/TypeNode"

// Constants
const ITERABLE_CAPACITY 128 end

// === Array ===
// README:
//    Array is a contiguous memory containing list of 64-bit values.
//    => Value at the list pointer represents the amount of items in the list.
//    => The first index of the list comes after the length (ptr + 8 bytes).

// Initialize an array of certain size
// Include space for one extra integer (list length)
// Params: size (INT)
// Return: array (PTR)
function Array.init int -> Array :
  // Allocate memory for the array
  ptr.size * int.size + malloc cast_any

  // Set the size to 0
  0 over int.store
end

function Array.load ptr -> Array :
  ptr.load cast_any
end

function Array.store ptr Array :
  swap ptr swap ptr.store
end

// Free the allocated memory for a certain array
// Params: array (PTR)
// Return: None
function Array.delete Array :
  take array in
  array Array.size
  array ptr munmap
end

// Get the length of an array (number of elements)
// Params: array (PTR)
// Return: len (INT)
function Array.len Array -> int :
  // The length is stored at the array pointer
  ptr int.load
end

// Get array's allocated memory size in bytes
// Params: array (PTR)
// Return: size (INT)
function Array.size Array -> int :
  Array.len int.size * int.size +
end

// Empty the array by setting the length value to 0
// Params: array (PTR)
// Return: None
function Array.empty Array :
  0 swap ptr int.store
end

// Copy the array to new memory location
// Params: array (PTR)
// Return: new_array (PTR)
function Array.copy Array -> Array :
  // Initialize variables
  dup Array.len ptr.size * int.size +
  dup Array.init
  take
    new_array
    memory_size
    old_array
  in

  // Copy the old memory to the new location
  memory_size old_array ptr new_array ptr memcpy
  new_array
end

// Get pointer to the first element of the array
// Params: array (PTR)
// Return: array[0] (PTR)
function Array.first Array -> ptr :
  ptr int.size ptr+
end

// Get pointer to the Nth element of the array
// Params: array (PTR), N (INT)
// Return: array[N] (PTR)
function Array.nth Array int -> ptr :
  dup Array.len
  take len array N in

  // Exit with error if Nth element does not exist
  if
    N len >
    N 0 <
    ||
  do
    "[ERROR] Cannot get " eputs
    N   eputi ". value from the array with " eputs
    len eputi " items\n" eputs
    0 exit NULL ptr
    return
  endif

  // Return pointer to the Nth element from the array
  array ptr N ptr.size * int.size + ptr+
end

// Append value pointer to an array
// Params: array (PTR), value (ANY)
// Return: list (PTR)
function Array.append Array any :
  dup Array.len
  take
    len
    array
    value
  in

  // Add the value to the end of the Array
  array ptr int.size ptr+
  ptr.size len * ptr+
  value swap
  ptr.store

  // Increment the Array's length by one
  len 1 + array ptr int.store
end

// Remove an item from the certain index of the Array
// Params: array, index
// Return: None
function Array.pop Array int :
  dup Array.len
  take
    len
    array
    index
  in

  // Report error and exit if the index cannot be popped
  if
    index len >=
    index 0 <
    ||
  do
    "Cannot pop index " eputs
    index eputi
    " from array of length " eputs
    len eputi "\n" eputs
    1 exit
  endif

  while index len 1 - < do
    // array[index] = array[index+1]
    index 1 + array Array.nth ptr.load
    index array Array.nth ptr.store
    index 1 + index =
  done

  // Decrement the Array.len
  len 1 - array ptr int.store
end

// Test if array contains an integer
// Params: Array[int], int
// Return: bool
function Array.contains_int Array int -> bool :
  dup Array.len
  0
  take
    index
    len
    array
    integer
  in

  while index len < do
    index array Array.nth int.load
    take array_int in

    // Return True if the current integer matches with the parameter
    if integer array_int == do
      True return
    endif
    index 1 + index =
  done
  False
end

// Test if array contains a string
// Params: Array[str], str
// Return: bool
function Array.contains_str Array str -> bool :
  dup Array.len
  0
  take
    index
    len
    array
    string
  in

  while index len < do
    index array Array.nth str.load
    take array_string in

    // Return True if the current string matches with the parameter
    if string array_string streq do
      True return
    endif
    index 1 + index =
  done
  False
end

// Test if two Arrays have equal integer-like items in them
// Params: Array[int], Array[int]
// Return: bool
function Array.equals Array Array -> bool :
  dup   Array.len
  over  Array.len
  0
  take
    index
    array2.len
    array1.len
    array1
    array2
  in

  // Arrays of different length cannot be equal
  if array1.len array2.len != do
    False return
  endif

  // Iterate over every item in arrays and check if they are equal
  while index array1.len < do
    if
      index array1 Array.nth int.load
      index array2 Array.nth int.load
      !=
    do
      False return
    endif
    index 1 + index =
  done
  True
end

// Test if two Arrays have equal strings in them
// Params: Array[str], Array[str]
// Return: bool
function Array.streq Array Array -> bool :
  dup   Array.len
  over  Array.len
  0
  take
    index
    array2.len
    array1.len
    array1
    array2
  in

  // Arrays of different length cannot be equal
  if array1.len array2.len != do
    False return
  endif

  // Iterate over every item in arrays and check if the strings are equal
  while index array1.len < do
    if
      index array1 Array.nth str.load
      index array2 Array.nth str.load
      streq not
    do
      False return
    endif
    index 1 + index =
  done
  True
end

// Print array of integer-like values
// Params: array (PTR)
// Return: None
function Array.print Array :
  dup ptr int.load
  take len array in
  0 while dup len < do
    array Array.first
    over ptr.size *
    ptr+ int.load print " " puts
    1 +
  done drop
end

// Print array of strings
// Params: array (PTR)
// Return: None
function Array.puts Array :
  dup ptr int.load
  take len array in
  0 while dup len < do
    array Array.first
    over ptr.size *
    ptr+ str.load puts
    1 +
  done drop
end

// === List ===
// README:
//    Lists are like arrays, but with dynamic resizing.
//    They use Arrays as the backend of the implementation.
//
//    List will reallocate a new array double the size
//    of the original when an overflow would happen.
//
//    The List object only contains a pointer to array
//    and the capacity of the allocated array.
//
//    Initial capacity for a new List equals ITERABLE_CAPACITY.

// List(array: ptr, capacity: int, length: int)
ENUM List.size 8 :
  List.array    // ptr to array
  List.capacity // int
END

// Initialize list with a size of ITERABLE_CAPACITY
// Params: None
// Return: list (PTR)
function List.init -> List :
  // Allocate memory for the initial array
  ITERABLE_CAPACITY Array.init cast_any
  take array in

  // Allocate memory for List object
  List.size malloc cast_any
  take list in

  // List(array=array, capacity=ITERABLE_CAPACITY)
  array             list List.array     ptr+ ptr.store
  ITERABLE_CAPACITY list List.capacity  ptr+ int.store
  list
end

// List getters
function List.get_array List -> Array :
  ptr Array.load
end

function List.get_capacity List -> int :
  ptr List.capacity ptr+ int.load
end

// List setters
function List.set_array List Array :
  ptr Array.store
end

function List.set_capacity List int :
  ptr List.capacity ptr+ int.store
end

function List.load ptr -> List :
  ptr.load cast_any
end

function List.store ptr List :
  swap ptr swap ptr.store
end

// Free the allocated memory for a certain list
function List.delete List :
  dup List.get_array
  take array list in

  // Deallocate the array pointed by List.array
  array Array.delete

  // Deallocate the List object
  List.size list ptr munmap
end

// Append value pointer to a list
// Params: list (PTR), value (ANY)
// Return: list (PTR)
function List.append List any :
  take list value_ptr in

  list List.get_capacity  // Capacity of the list
  list List.get_array     // Pointer to array
  dup Array.len           // Length of the array

  // Store values from the stack to variables
  take
    len
    array
    capacity
  in

  // Allocate bigger array if the current capacity is full
  if capacity len == do
    // Allocate an array double of the size of the original
    len 2 * capacity =
    capacity Array.init
    take new_array in

    // Update list capacity
    capacity list List.set_capacity

    // Copy the old array to new_array
    // dest (PTR), src (PTR), len (INT)
    array Array.size array ptr new_array ptr memcpy

    // Update new array length
    len new_array ptr int.store

    // Deallocate the old array
    array Array.delete

    // Set the new_array to array
    new_array array =

    array list List.set_array
  endif

  // Add the value_ptr to the end of the list
  value_ptr array Array.append
end

// Get the length of a list
// Params: list (PTR)
// Return: len (INT)
function List.len List -> int :
  List.get_array Array.len
end

// Empty the list by setting the length value of pointed array to 0
// Params: list (PTR)
// Return: None
function List.empty List :
  List.get_array Array.empty
end

// Copy the list to new memory location
function List.copy List -> List :
  // Initialize variables
  dup List.len ptr.size * int.size +
  List.init
  take
    new_list
    memory_size
    old_list
  in

  // Copy the old memory to the new location
  memory_size old_list ptr new_list ptr memcpy
  new_list
end

// Get pointer to the first element of the list
// Params: list (PTR)
// Return: list[0] (PTR)
function List.first List -> ptr :
  0 swap List.nth
end

// Get pointer to the last element of the list
// Params: list (PTR)
// Return: list[0] (PTR)
function List.last List -> ptr :
  dup List.len 1 - swap List.nth
end

// Get pointer to the Nth element of the list
// Params: list (PTR), N (INT)
// Return: list[N] (PTR)
function List.nth List int -> ptr :
  List.get_array Array.nth
end

// Remove an item from the certain index of the list
// Params: List, index
// Return: None
function List.pop List int :
  List.get_array Array.pop
end

// Test if two Arrays have equal integer-like items in them
// Params: List[int], List[int]
// Return: bool
function List.equals List List -> bool :
  List.get_array
  swap List.get_array
  Array.equals
end

// Test if two Arrays have equal strings in them
// Params: List[str], List[str]
// Return: bool
function List.streq List List -> bool :
  List.get_array
  swap List.get_array
  Array.streq
end

// Test if list contains an integer
// Params: List[int], int
// Return: bool
function List.contains_int List int -> bool :
  List.get_array Array.contains_int
end

// Test if list contains a string
// Params: List[str], str
// Return: bool
function List.contains_str List str -> bool :
  List.get_array Array.contains_str
end

// === LinkedList ===
// README:
//    LinkedList is a doubly linked list of Nodes linked by pointers.
//    TODO: Rename LinkedList to indicate it is a doubly linked lists
//    LinkedList.init returns a pointer to the head Node.
function LinkedList.init -> Node :
  ptr.size malloc cast_any
  NULLPTR over ptr.store
end

enum Node.size 8 :
  Node.data // PTR
  Node.next // PTR
  Node.prev // PTR
end

function Node.get_data Node -> ptr :
  ptr ptr.load
end

function Node.get_next Node -> Node :
  ptr Node.next ptr+ Node.load
end

function Node.get_prev Node -> Node :
  ptr Node.prev ptr+ Node.load
end

function Node.set_data Node ptr :
  ptr ptr.store
end

function Node.set_next Node ptr :
  ptr Node.next ptr+ ptr.store
end

function Node.set_prev Node ptr :
  ptr Node.prev ptr+ ptr.store
end

function Node.load ptr -> Node :
  ptr.load cast_any
end

function Node.store ptr Node :
  swap cast_any swap ptr.store
end

// Push Node to LinkedList
// Params
//    head_ptr: Node
//    new_data: ptr
// Return None
function LinkedList.push Node ptr :
  dup ptr Node.load

  // Allocate new Node
  Node.size malloc cast_any
  take
    new_node
    head_node
    head_ptr
    new_data
  in

  // Store data to new Node
  new_data new_node Node.set_data

  // Make the old head new Node's next and previous as NULL
  head_node ptr new_node Node.set_next
  NULL cast_any new_node Node.set_prev

  // Set the old head's prev to point to new Node
  if head_node int NULL != do
    new_node head_node Node.set_prev
  endif

  // Insert the new Node to head_ptr
  new_node head_ptr ptr Node.store
end

// Pop Node from LinkedList
// Return -1 if head is NULL
// Params
//    head_ptr: Node
// Return
//    popped_data: ptr
function LinkedList.pop Node -> ptr :
  dup ptr Node.load
  take head head_ptr in

  // Underflow condition
  if head int NULL == do
    -1 ptr return
  endif

  // Get the old head data
  head Node.get_data
  take popped_data in

  // Unlink the old head
  head Node.get_next head_ptr ptr Node.store

  // Deallocate the old head
  Node.size head ptr munmap

  // Return the popped data
  popped_data
end

// Get the length of a LinkedList
// Params
//    head_ptr: Node
// Return
//    length: int
function LinkedList.len Node -> int :
  ptr Node.load 0
  take count current in

  while current int NULL != do
    count 1 + count =
    current Node.get_next
    current =
  done
  count
end

// Check if LinkedList is empty
// Params
//    head_ptr: Node
// Return bool
function LinkedList.is_empty Node -> bool :
  ptr int.load 0 ==
end
