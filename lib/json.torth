include "std"
include "parser"
include "typing"

class JsonValue
    value:any
    type:str

    method init value:any type:str -> JsonValue :
        JsonValue.size malloc cast(JsonValue)
        take json_value in

        // Validate arguments
        if type JsonValue.is_valid_type not do
            NULL cast(JsonValue) return
        endif

        value       json_value JsonValue->value
        type        json_value JsonValue->type
        json_value
    end

    method repr self:JsonValue -> str :
        self JsonValue.type take type in

        if type "null" streq do
            "null" return
        elif type "boolean" streq do
            if self JsonValue.value cast(bool) do
                "true" return
            else
                "false" return
            endif
        elif type "number" streq do
            self JsonValue.value itoa return
        elif type "string" streq do
            self JsonValue.value cast(str) return
        endif

        if type JsonValue.is_valid_type do
            f"JsonValue.repr is not yet implemented for type '{type}'\n" eputs
            1 exit
        endif

        f"Unknown JsonValue.type '{type}'" eputs
        1 exit
        "unreachable"
    end

    method is_valid_type type:str -> bool :
        type "null"     streq
        type "boolean"  streq ||
        type "number"   streq ||
        type "string"   streq ||
        type "array"    streq ||
        type "object"   streq ||
    end
endclass

function parse_json_boolean parser:Parser -> str :
    parser Parser.get_unparsed take unparsed in

    if "true" parser Parser.parse_string str.len 0 > do
        "true" return
    endif

    "false" parser Parser.parse_string
end

// Only integers are supported
function parse_number parser:Parser -> str :
    parser Parser.get_unparsed cast(ptr) char.load
    take current_char in

    if current_char char.is_numeric not do
        "" return
    endif

    current_char char.to_string
end

function parse_double_quote parser:Parser -> str :
    '"' parser Parser.parse_character
end

function parse_json_string parser:Parser -> str :
    // Opening double quote
    '"' parser Parser.parse_character
    take double_quote in
    if double_quote str.len 0 == do
        "" return
    endif

    parse_double_quote& parser Parser.parse_until
    take string in
    if string str.len 0 == do
        "" return
    endif

    '"' parser Parser.parse_character drop
    // Enclose string in quotes
    f"{double_quote}{string}{double_quote}"
end

function string_to_bool string:str -> bool :
    if string "true" streq do
        True return
    elif string "false" streq do
        False return
    endif

    f"Invalid JSON boolean: {string}" eputs
    1 exit
    False // unreachable
end

// Returns NULL if the input is not valid JSON
function parse_json input:str -> JsonValue :
    input Parser.init
    take parser in

    // null
    "null" parser Parser.parse_string
    take parsed_null in

    parsed_null puts
    if parsed_null str.len 0 > do
        "null" "null" JsonValue.init return
    endif

    // boolean
    parse_json_boolean& parser Parser.parse_predicate
    take parsed_boolean in
    if parsed_boolean str.len 0 > do
        "boolean" parsed_boolean string_to_bool JsonValue.init return
    endif

    // number
    parse_number& parser Parser.parse_while
    take parsed_number in
    if parsed_number str.len 0 > do
        "number" parsed_number atoi JsonValue.init return
    endif

    // string
    parse_json_string& parser Parser.parse_predicate
    take parsed_string in
    if parsed_string str.len 0 > do
        "string" parsed_string JsonValue.init return
    endif

    NULL cast(JsonValue)
end
