include "std"
include "parser"
include "typing"

class JsonValue
    value:any
    type:str

    method init value:any type:str -> JsonValue :
        JsonValue.size malloc cast(JsonValue)
        take json_value in

        // Validate arguments
        if type JsonValue.is_valid_type not do
            NULL cast(JsonValue) return
        endif

        value       json_value JsonValue->value
        type        json_value JsonValue->type
        json_value
    end

    method repr self:JsonValue -> str :
        self JsonValue.type take type in

        if type "null" streq do
            "null" return
        elif type "boolean" streq do
            if self JsonValue.value cast(bool) do
                "true" return
            else
                "false" return
            endif
        elif type "number" streq do
            self JsonValue.value itoa return
        elif type "string" streq do
            self JsonValue.value cast(str) return
        elif type "array" streq do
            self JsonValue.value cast(List)
            "[" str.copy
            0
            take
                index
                repr
                array_items
            in

            while index array_items List.len < do
                index array_items List.nth ptr.load cast(JsonValue) JsonValue.repr
                repr swap str.cat repr =
                index 1 + index =

                if index array_items List.len < do
                    ',' repr str.append repr =
                endif
            done

            ']' repr str.append return
        endif

        if type JsonValue.is_valid_type do
            f"JsonValue.repr is not yet implemented for type '{type}'\n" eputs
            1 exit
        endif

        f"Unknown JsonValue.type '{type}'" eputs
        1 exit
        "unreachable"
    end

    method is_valid_type type:str -> bool :
        type "null"     streq
        type "boolean"  streq ||
        type "number"   streq ||
        type "string"   streq ||
        type "array"    streq ||
        type "object"   streq ||
    end
endclass

function parse_json_boolean parser:Parser -> str :
    parser Parser.get_unparsed take unparsed in

    if "true" parser Parser.parse_string str.len 0 > do
        "true" return
    endif

    "false" parser Parser.parse_string
end

// Only integers are supported
function parse_number parser:Parser -> str :
    parser Parser.get_unparsed cast(ptr) char.load
    take current_char in

    if current_char char.is_numeric not do
        "" return
    endif

    current_char char.to_string
end

function parse_double_quote parser:Parser -> str :
    '"' parser Parser.parse_character
end

function parse_json_string parser:Parser -> str :
    // Opening double quote
    '"' parser Parser.parse_character
    take double_quote in
    if double_quote str.len 0 == do
        "" return
    endif

    parse_double_quote& parser Parser.parse_until
    take string in
    if string str.len 0 == do
        "" return
    endif

    '"' parser Parser.parse_character drop
    // Enclose string in quotes
    f"{double_quote}{string}{double_quote}"
end

function parse_json_array parser:Parser -> List[JsonValue] :
    if '[' parser Parser.parse_character str.len 0 == do
        NULL cast(List[JsonValue]) return
    endif

    List.init cast(List[JsonValue])
    take json_array in
    parser Parser.parse_whitespace drop
    while ']' parser Parser.parse_character str.len 0 == do
        // Parse array item
        parser json_parser take array_item in
        if array_item cast(int) NULL == do
            NULL cast(List[JsonValue]) return
        endif

        // Append the array item to list
        array_item json_array cast(List) List.append

        // Comma separates array items
        parser Parser.parse_whitespace drop
        ',' parser Parser.parse_character drop
        parser Parser.parse_whitespace drop
    done

    json_array
end

function string_to_bool string:str -> bool :
    if string "true" streq do
        True return
    elif string "false" streq do
        False return
    endif

    f"Invalid JSON boolean: {string}" eputs
    1 exit
    False // unreachable
end

function json_parser parser:Parser -> JsonValue :
    // null
    "null" parser Parser.parse_string
    take parsed_null in
    if parsed_null str.len 0 > do
        "null" "null" JsonValue.init return
    endif

    // boolean
    parse_json_boolean& parser Parser.parse_predicate
    take parsed_boolean in
    if parsed_boolean str.len 0 > do
        "boolean" parsed_boolean string_to_bool JsonValue.init return
    endif

    // number
    parse_number& parser Parser.parse_while
    take parsed_number in
    if parsed_number str.len 0 > do
        "number" parsed_number atoi JsonValue.init return
    endif

    // string
    parse_json_string& parser Parser.parse_predicate
    take parsed_string in
    if parsed_string str.len 0 > do
        "string" parsed_string JsonValue.init return
    endif

    // array
    parser parse_json_array
    take json_array in
    if json_array cast(int) NULL != do
        "array" json_array JsonValue.init return
    endif

    NULL cast(JsonValue)
end

// Returns NULL if the input is not valid JSON
function parse_json input:str -> JsonValue :
    input Parser.init json_parser
end
