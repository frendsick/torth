// std.torth - Standard library for Torth
// A collection of common functions

// Include libraries
include "errno"
include "math"
include "sys"
include "typing"

// Common constants
const NULL 0 end

// Memory
const MEMORY_CAPACITY 430080 end  // 420 * 1024 => 420kb

// Data types
const bool.size   1 end
const char.size   1 end
const int.size    8 end
const ptr.size    8 end
const str.size    8 end
const uint8.size  1 end

// Temporary memories
memory temp_bool  bool.size   end
memory temp_char  char.size   end
memory temp_int   int.size    end
memory temp_ptr   ptr.size    end
memory temp_str   str.size    end
memory temp_uint8 uint8.size  end

// File descriptors
const stdin  0 end
const stdout 1 end
const stderr 2 end

// Usual file modes
const mode_777 0x1ff end
const mode_755 0x1ed end
const mode_750 0x1e8 end
const mode_700 0x1c0 end
const mode_644 0x1a4 end
const mode_640 0x1a0 end
const mode_600 0x180 end

// Extra intrinsics
function NULLPTR            -> ptr  : NULL ptr              end
function div      int int   -> int  : divmod swap drop      end
function mod      int int   -> int  : divmod drop           end
function /        int int   -> int  : div                   end
function %        int int   -> int  : mod                   end
function ^        int int   -> int  : pow                   end
function not      bool      -> bool : True !=               end
function |        int int   -> int  : or                    end
function lor      bool bool -> bool : int swap int or bool  end
function land     bool bool -> bool : int swap int and bool end
function ||       bool bool -> bool : lor                   end
function &&       bool bool -> bool : land                  end

// Get user input from stdin
function input -> str :
  // Allocate memory for the user input
  MEMORY_CAPACITY malloc
  MEMORY_CAPACITY over str stdin read // Returns the amount of bytes read

  // Remove the newline character from the end
  over swap 1 - ptr+ NULL char swap char.store str
end

// Write a string to a file descriptor
// Params: int fd, char *buf, size_t count
// Return: ssize_t written_bytes
function write int str int -> int : SYS_write syscall3 end

// Read <count> bytes from a file descriptor
// Params: int fd, char *buf, size_t count
// Return: ssize_t read_bytes
function read int str int -> int : SYS_read syscall3 end

// Execute the command referred to by <pathname>
// Params: const char *pathname, char *const argv[], char *const envp[]
// Return: On success, execve does not return, on error -1 is returned
function execve str ptr ptr -> int : SYS_execve syscall3 end

// Exit from the program with a <status> code
// Params: int status
// Return: None
function exit int : SYS_exit syscall1 drop end

// Print a string to a file descriptor
// Params: int fd, char *buf
// Return: None
function fputs int str : swap dup str.len swap rot write drop end

// Allocate read-write memory and return the pointer to the allocated memory
// Params: size_t length
// Return: Pointer to the start of the allocated memory
function malloc int -> ptr :
  // Allocate at least one byte
  if dup 0 == do drop 1 endif
  take length in

  // mmap ( NULL, length, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0 );
  0 0
  MAP_ANONYMOUS MAP_PRIVATE |
  PROT_READ PROT_WRITE |
  length
  NULL SYS_mmap SYSCALL6 ptr
end

// Deallocate memory
// Params: pointer (PTR), len (INT)
// Return: None
function munmap ptr int :
  SYS_munmap SYSCALL2 drop
end

// Copy N characters from one memory location to another
// Params: dest (PTR), src (PTR), len (INT)
// Return: None
function memcpy ptr ptr int :
  0
  take index dest src len in
  while index len < do
    src  index ptr+ char.load
    dest index ptr+ char.store
    index 1 + index =
  done
end

// Print a string to stdout
function puts  str : stdout fputs end

// Print a string to stderr
function eputs str : stderr fputs end

// Print an unsigned integer to stdout
function putu int : print end

// Print an unsigned integer to stderr
function eputu int : itoa eputs end

// Print a signed integer to stdout
function puti int : itoa puts end

// Print a signed integer to stderr
function eputi int : itoa eputs end

// Ptr functions
function ptr+       int ptr -> ptr : swap int + ptr end
function ptr-       int ptr -> ptr : swap int - ptr end
function ptr++      ptr     -> ptr : ptr.size ptr+  end
function ptr.load   ptr     -> ptr : LOAD_QWORD ptr end
function ptr.store  ptr ptr ->     : STORE_QWORD    end

// Bool functions
function bool.load  ptr       -> bool : LOAD_BYTE bool  end
function bool.store ptr bool  ->      : STORE_BYTE      end

// Char functions
function char.load  ptr       -> char : LOAD_BYTE char  end
function char.store ptr char  ->      : STORE_BYTE      end

// Return the lowercase character for the given character
function char.lower char -> char :
  if dup char.is_uppercase do 32 + char endif
end

// Return the uppercase character for the given character
function char.upper char -> char :
  if dup char.is_lowercase do 32 - char endif
end

// Test if character is a number
function char.is_numeric char -> bool :
  dup   '0' >=
  swap  '9' <=
  &&
end

// Test if a character is a lowercase letter
function char.is_lowercase char -> bool :
  dup  'a' >=
  swap 'z' <=
  &&
end

// Test if a character is an uppercase letter
function char.is_uppercase char -> bool :
  dup  'A' >=
  swap 'Z' <=
  &&
end

// Test if a character is a letter
function char.is_letter char -> bool :
  dup  char.is_uppercase
  swap char.is_lowercase
  ||
end

// Test if a character is either a letter or a number
function char.is_alphanumeric char -> bool :
  dup  char.is_letter
  swap char.is_numeric
  ||
end

// Test if a character is some whitespace character
function char.is_whitespace char -> bool :
  take c in
  c ' ' ==  // Space
  c 9   ==  // Tab \t
  c 10  ==  // Line feed \n
  c 13  ==  // Carriage return \r
  || || ||  // Logical OR each of the comparisons
end

function char.to_string char -> str :
  "" str.copy
  take string character in
  character string str.append
  string
end

// Int functions
function int.load     ptr       -> int    : LOAD_QWORD int    end
function int.store    ptr int   ->        : STORE_QWORD       end
function uint8.load   ptr       -> uint8  : LOAD_BYTE uint8   end
function uint8.store  ptr uint8 ->        : STORE_BYTE        end

// Get the amount of digits in an integer
// Params: number
// Return: amount_of_digits
// Example: 1234 -> 4
function int.get_digits int -> int :
  // The amount of digits == 1 if the integer is 0
  if dup 0 == do
    drop 1
  else
    0 swap while dup 0 != do
      10 /
      swap 1 + swap
    done drop
  endif
end

// Reverse an integer
// Example: 1234 --> 4321
function int.reverse int -> int :
  0 while over 0 > do
    10 * swap dup 10 % rot +
    swap 10 / swap
  done swap drop
end

// Convert negative integer to positive
function int.to_positive int -> int :
  if dup 0 < do 2 ^ sqrt endif
end

// Get a string representation of an integer
function itoa int -> str :
  // Return "0" if parameter is 0
  if dup 0 == do
    drop "0" return
  endif

  // Swap sign of negative number
  dup 0 < take is_negative in
  if is_negative do
    int.to_positive
  endif

  // Allocate memory to the string representation
  dup int.get_digits  // digits
  dup 2 + malloc str  // string

  // Add '-' character to the start of string for negative number
  if is_negative do
    '-' over str.append
  endif

  10 // base
  take base string digits num in

  // Process individual digits: https://www.geeksforgeeks.org/implement-itoa/
  0 while dup digits < do
    num base %  // rem = num/base

    // str[index] = (rem > 9)? (rem-10) + 'a' : rem + '0';
    if dup 9 >
    do    10 - 'a' +
    else  '0' +
    endif char
    string str.append

    num base / num  = // num = num/base
    1 + // index++
  done drop string

  // Reverse for correct processing
  str.reverse
end

// Get an integer representation of a string
function atoi str -> int :
  NULL 0 take index integer string in
  // Iterate the string character by character
  while string index str.char_at NULL != do

    // Get current character
    string index str.char_at

    // Raise an error if the character is not a number
    if dup char.is_numeric not do
      "[ERROR] atoi function failed: '"
      string                    str.cat
      "' is not an integer.\n"  str.cat
      eputs 1 exit
    endif

    // Append the current character to integer
    '0' -
    integer 10 * +
    integer =
    index 1 + index = // index++
  done integer
end

// String functions
function str+         int str   -> str  : swap int + ptr str  end
function str.load     ptr       -> str  : LOAD_QWORD str      end
function str.store    ptr str   ->      : STORE_QWORD         end

// Copy string to a newly allocated memory location and return the copied string
function str.copy str -> str :
  // Allocate memory which can store the string
  dup str.len malloc
  swap  // str
  str.fill
end

// Get the length of a string
// Example: "Test string" -> 11
function str.len str -> int :
  take string in
  0 while string over str.char_at NULL != do
    1 +
  done
end

// Fill a ptr with the contents of a string
function str.fill str ptr -> str :
  take string pointer in
  0 // index
  // Loop through every character of the first string
  while string over str.char_at NULL != do
    string over str.char_at
    over pointer swap ptr+ char.store
    1 +
  done drop
  pointer str
end

// Insert a string inside another strings at certain index
// Params: index, str2, str1
// Return: str1[:index] + str2 + str1[index:]
function str.insert_at int str str -> str :
  take index str2 str1 in

  if index str1 str.len >= do
    "[ERROR] str.index_at function failed: '"
    str1                      str.cat
    "' does not have index "  str.cat
    index itoa                str.cat
    "\n"                      str.cat
    eputs 1 exit
  endif

  // Allocate memory to hold both strings
  str1 str.len
  str2 str.len
  1 + // NULL byte
  + malloc
  take final_str in

  // Split the str2 from the index
  str1 index str+ str.copy
  take str1_end in
  str1 index str+ NULL char swap ptr char.store

  final_str str1 str.fill
  str2 str.cat
  str1_end str.cat
end

// Replace escape sequences with the corresponding characters
// Example: "Escape newline\n" => "Escape newline<LF>"
function str.escape str -> str :
  9  char char.to_string
  10 char char.to_string
  13 char char.to_string
  27 char char.to_string
  92 char char.to_string
  take
    backslash
    Escape
    CR
    LF
    Tab
    string
  in

  // Save escape sequences to variables
  Tab     backslash "t" str.cat string  str.replace_all
  LF      backslash "n" str.cat rot     str.replace_all
  CR      backslash "r" str.cat rot     str.replace_all
  Escape  backslash "e" str.cat rot     str.replace_all
end

// Get the index of the first character of a substring from a string
// Return -1 if substring is not found
// Params: string, substring
// Return: index
function str.find str str -> int :
  over str.len
  over str.len
  0
  take
    index
    string.len
    substring.len
    string
    substring
  in

  // Return -1 if substring is longer than the string
  // or the substring is 0 length
  if
    substring.len string.len >
    substring.len 0 <=
    ||
  do
    -1 return
  endif

  while index string.len substring.len - <= do

    // Index was found if the current string starts with the substring
    if string substring str.startswith do
      index return
    endif

    // Increment string pointer and index
    string 1 str+ string =
    index 1 + index =
  done

  // String was not found
  -1
end

// Replace first occurrence of substring with another string.
// Return the original string if substring is not found
// Params: string, substring, replacement
// Return: string
function str.replace str str str -> str :
  take
    string
    substring
    replacement
  in

  // Get the index of the first substring match
  substring string str.find
  take index in

  // Return the original string if no match was found
  if index 0 < do
    string return
  endif

  // Split the string from the index
  string index str+ ptr NULL char swap char.store
  string index substring str.len + str+
  take string_end in

  string
  replacement str.cat
  string_end  str.cat
end

// Replace all occurrences of substring with another string.
// Return the original string if substring is not found.
// Params: string, substring, replacement
// Return: string
function str.replace_all str str str -> str :
  take
    string
    substring
    replacement
  in

  while True do

    // Save the current string as old_string
    string take old_string in

    // Return if str.replace does not do changes
    replacement substring string str.replace
    take new_string in
    if new_string old_string streq do
      new_string return
    endif

    // Use the new string in the next iteration as old_string
    new_string string =
  done
  new_string
end

// Concatenate two strings into a new memory location
// Params: str1, str2
// Return: concat(str1+str2)
function str.cat str str -> str :
  // Save str1 and str2
  take str1 str2 in

  // Allocate memory to hold both strings
  str1 str.len
  str2 str.len
  1 + // NULL byte
  + malloc

  // Fill the beginning of the allocated memory with str2
  str2 str.fill
  take final_str in

  // Append str1 to str2
  final_str dup str.len str+ ptr
  str1 str.fill drop
  final_str
end

// Free the parameter string's memory
function str.delete str :
  dup str.len 1 + swap ptr munmap
end

// Append a character to the end of a string buffer
// Params: string, character
// Return: None
function str.append str char : ptr dup str str.len ptr+ char.store end

// Get the character at a certain index of a string
// Params: index, string
// Return: character_at_index
function str.char_at int str -> char : swap ptr swap ptr+ char.load end

// Test if a string is a palindrome (reads the same backward or forward)
function str.is_palindrome str -> bool : dup str.reverse streq end

// Test if string only contains numeric characters
function str.is_numeric str -> bool :
  take string in

  // Check for negative numbers
  if string ptr char.load '-' == do
    string 1 str+ string =
  endif

  // Iterate over every character of the string
  while string ptr char.load NULL != do
    // Break if non-numeric character is found
    if string ptr char.load char.is_numeric not do
      break
    endif
    string 1 str+ string = // Point to the next character
  done
  // Return True if the whole string was numeric
  string str.len 0 ==
end

// Overwrite a string with NULL-bytes
function str.empty str :
  take string in
  0 while string over str.char_at NULL != do
    string over str+ ptr NULL char swap char.store
    1 +
  done drop
end

// Convert string to lowercase letters
function str.lower str -> str :
  dup str.len // len
  0           // index
  take index len string in

  // Rewrite string with lowercase characters
  while index len < do
    string index str.char_at char.lower
    string ptr index ptr+ char.store
    index 1 + index = // index++
  done string
end

// Convert string to uppercase letters
function str.upper str -> str :
  dup str.len // len
  0           // index
  take index len string in

  // Rewrite string with uppercase characters
  while index len < do
    string index str.char_at char.upper
    string ptr index ptr+ char.store
    index 1 + index = // index++
  done string
end

// Strip all non-alphanumeric characters from a string
function str.alphanumeric str -> str :
  // Allocate enough memory to hold the whole string
  dup str.len malloc str
  swap
  0 while over str.len over > do
    // Get the current character
    over over str.char_at

    // Append only alphanumeric characters
    // memory str index str[index]
    if dup char.is_alphanumeric do
      // Append the current character to the new string
      dup 5 nth str.append
    endif drop
    1 + // index++
  done drop drop
end

// Check if a string starts with another string
// Params: prefix (STR), string (STR)
// Return: True/False
function str.startswith str str -> bool :
  over str.len
  over str.len
  0
  take
    index
    prefix.len
    string.len
    prefix
    string
  in

  // Return False if prefix.len > string.len
  if prefix.len string.len > do
    False return
  endif

  while index prefix.len < do
    if
      string index str.char_at
      prefix index str.char_at
      !=
    do
      False return
    endif
    index 1 + index = // index++
  done
  True
end

// Check if a string ends with another string
// Params: suffix (STR), string (STR)
// Return: True/False
function str.endswith str str -> bool :
  over str.len
  over str.len
  0
  take
    index
    suffix.len
    string.len
    suffix
    string
  in

  // Return False if suffix.len > string.len
  if suffix.len string.len > do
    False return
  endif

  while index suffix.len < do
    if
      string string.len index - 1 - str.char_at
      suffix suffix.len index - 1 - str.char_at
      !=
    do
      False return
    endif
    index 1 + index = // index++
  done
  True
end

// Remove a suffix if it exists. Otherwise return the original string.
// Params: string (STR), string (STR)
// Return: None
function str.removesuffix str str :
  over str.len
  over str.len
  take
    string.len
    suffix.len
    string
    suffix
  in
  // Clear the suffix if it exists
  if string suffix str.endswith do
    string ptr string.len suffix.len -
    ptr+ str str.empty
  endif
end

// Tests if two strings are equal
function streq str str -> bool :
  // Bind strings to memory
  take str1 str2 in

  // while index < len(str1)
  0 while
    str1 over dup
    take index in
    swap str.len <
  do
    if // str1[index] != str2[index]
      str1 index str.char_at
      str2 index str.char_at
      !=
    do break
    endif 1 +
  done drop

  // Strings are not equal if the last checked character is not equal
  if
    str1 index str.char_at
    str2 index str.char_at
    !=
  do False
  else True
  endif
end

// Reverse a string
function str.reverse str -> str :
  // Allocate memory for the reversed string
  dup str.len dup malloc str
  take reversed index original in

  // Append characters from the parameter string to allocated memory in the reversed order
  while 0 index < do
    index 1 - index =           // index--
    original index str.char_at  // original[index]

    // Append the current character to the reversed string
    reversed str.append
  done reversed
end

// https://en.wikibooks.org/wiki/Algorithm_Implementation/Miscellaneous/Base64
function base64.encode str -> str :
  dup str.len
  dup 3 %
  over 2 * malloc str
  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/" str.copy
  0
  0
  take
    padding_size
    base64_index
    base64_characters
    base64_string
    char_index
    string.len
    string
  in

  // Add a right zero pad to make this string a multiple of 3 characters
  if char_index 0 > do
    char_index while dup 3 < do
      padding_size 1 + padding_size =
      1 +
    done drop
  endif

  // Increment over the length of the string, three characters at a time
  0 char_index = // Zero char_index
  while char_index string.len < do

    // These three 8-bit (ASCII) characters become one 24-bit number
    string char_index     str.char_at 16 shl
    string char_index 1 + str.char_at 8 shl +
    string char_index 2 + str.char_at +
    take 24bit_number in

    // This 24-bit number gets separated into four 6-bit numbers
    list.init
    24bit_number 18 shr 63 and ptr swap list.append
    24bit_number 12 shr 63 and ptr swap list.append
    24bit_number 6  shr 63 and ptr swap list.append
    24bit_number        63 and ptr swap list.append
    take 6bit_list in

    // Those four 6-bit numbers are used as indices into the base64 character list
    0 while dup 4 < do
      base64_characters over 6bit_list list.nth int.load str.char_at
      base64_string ptr base64_index ptr+ char.store
      base64_index 1 + base64_index = // base64_index++
      1 +
    done drop

    char_index 3 + char_index = // char_index += 3
  done

  // Append the padding characters and return the result
  NULL char base64_string dup str.len padding_size - str+ ptr char.store
  if    padding_size 1 ==
  do    base64_string "="   str.cat return
  elif  padding_size 2 ==
  do    base64_string "=="  str.cat return
  endif base64_string
end

// Open a file with open-syscall
// Params: int oflag, const char *path
// Return: fd
function open_file int str -> int :
  over SYS_open syscall2
  take fd path in
  if fd ENOENT == do
    "File '" eputs path eputs "' does not exist.\n" eputs
    1 exit
  elif fd EACCESS == do
    "Cannot open file '" eputs path eputs "': Permission denied.\n" eputs
    1 exit
  elif fd EFAULT == do
    "The 'path' argument for SYS_open points to inaccessible memory location.\n" eputs
    1 exit
  elif fd 0 < do
    "Error occurred while opening the file '" eputs path eputs "'.\n" eputs
    "Error code: " eputs fd eputi
    1 exit
  endif
  fd
end

// Read a file to a newly allocated memory
// Params: const char *pathname
// Return: ssize_t read_bytes
function read_file str -> str :
  O_RDONLY open_file
  MEMORY_CAPACITY malloc dup  // buf*
  rot                         // fd
  MEMORY_CAPACITY             // count
  rot str rot                 // Align stack
  read drop str               // Return the allocated memory location as string
end

// Create a file
// Params: const char *pathname, mode_t mode
// Return: int fd
function touch_file str int -> int :
  SYS_creat syscall2
end

// Write a string to a file
// Params: const char *filename, mode_t mode, const void *buf
// Return: ssize_t written_bytes
function write_file str int str -> int :
  // Create file
  touch_file

  // Write to the file
  take fd buf in
  buf str.len // size_t count
  buf fd SYS_write syscall3
end

// Print file contents to stdout
// Params: const char *pathname
// Return: ssize_t written_bytes
function print_file str :
  read_file puts
end

function file_exists str -> bool :
  O_RDONLY swap SYS_open syscall2
  take fd in

  if fd 0 > do
    fd SYS_close syscall1 drop
    True return
  endif
  False
end

// Sleep causes the calling thread to sleep either until the
// number of real-time seconds specified in parameters have elapsed or
// until a signal arrives which is not ignored.
// Params: How many seconds to sleep (STR)
// Return: None
// Usage: "4.2" sleep  // Sleep for 4.2 seconds
function sleep str :
  // Allocate memory for two strings
  str.size 2 * malloc take argv in

  // execve("/usr/bin/sleep", ["sleep", "0.01"], envp)
  "sleep" argv str.store
  argv ptr.size ptr+ str.store
  envp argv "/usr/bin/sleep" execve drop
end

// Get the value of certain environment variable
// Return NULL if variable is not found
// Params: evar_key (str)
// Return: evar_value
function getenv str -> str :
  0
  take index evar_key in

  // Check environment variables one by one
  while envp ptr.load int NULL != do
    envp index ptr.size * ptr+ str.load
    take evar_value in

    // Return the environment variable when found
    if evar_value evar_key str.startswith do
      0 while evar_value over str.char_at '=' != do
        1 +
      done

      // Get the string from the character after '='
      evar_value ptr swap 1 + ptr+ str
      return
    endif
    index 1 + index = // index++
  done

  // Return NULLPTR if evar_key was not found
  NULLPTR str
end
